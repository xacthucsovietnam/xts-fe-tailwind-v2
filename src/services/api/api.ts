/* tslint:disable */
/* eslint-disable */
/**
 * XTS Product Traceability API
 * XTS Product Traceability API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivationControllerCreate200Response
 */
export interface ActivationControllerCreate200Response {
    /**
     * 
     * @type {DetailActivationDocDto}
     * @memberof ActivationControllerCreate200Response
     */
    'data': DetailActivationDocDto;
    /**
     * 
     * @type {string}
     * @memberof ActivationControllerCreate200Response
     */
    'status': ActivationControllerCreate200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ActivationControllerCreate200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivationControllerCreate200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof ActivationControllerCreate200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof ActivationControllerCreate200Response
     */
    'messageCode'?: string;
}

export const ActivationControllerCreate200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type ActivationControllerCreate200ResponseStatusEnum = typeof ActivationControllerCreate200ResponseStatusEnum[keyof typeof ActivationControllerCreate200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface AddressItemDto
 */
export interface AddressItemDto {
    /**
     * 
     * @type {number}
     * @memberof AddressItemDto
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof AddressItemDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddressItemDto
     */
    'full_name': string;
}
/**
 * 
 * @export
 * @interface AppControllerGetCurrentUser200Response
 */
export interface AppControllerGetCurrentUser200Response {
    /**
     * 
     * @type {CurrentUserDto}
     * @memberof AppControllerGetCurrentUser200Response
     */
    'data': CurrentUserDto;
    /**
     * 
     * @type {string}
     * @memberof AppControllerGetCurrentUser200Response
     */
    'status': AppControllerGetCurrentUser200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AppControllerGetCurrentUser200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppControllerGetCurrentUser200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof AppControllerGetCurrentUser200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof AppControllerGetCurrentUser200Response
     */
    'messageCode'?: string;
}

export const AppControllerGetCurrentUser200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type AppControllerGetCurrentUser200ResponseStatusEnum = typeof AppControllerGetCurrentUser200ResponseStatusEnum[keyof typeof AppControllerGetCurrentUser200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface AuthControllerGetZaloAuthUrl200Response
 */
export interface AuthControllerGetZaloAuthUrl200Response {
    /**
     * 
     * @type {GetZaloLoginUrlResponseDto}
     * @memberof AuthControllerGetZaloAuthUrl200Response
     */
    'data': GetZaloLoginUrlResponseDto;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGetZaloAuthUrl200Response
     */
    'status': AuthControllerGetZaloAuthUrl200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGetZaloAuthUrl200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGetZaloAuthUrl200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof AuthControllerGetZaloAuthUrl200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGetZaloAuthUrl200Response
     */
    'messageCode'?: string;
}

export const AuthControllerGetZaloAuthUrl200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type AuthControllerGetZaloAuthUrl200ResponseStatusEnum = typeof AuthControllerGetZaloAuthUrl200ResponseStatusEnum[keyof typeof AuthControllerGetZaloAuthUrl200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface AuthControllerLeaveBusiness200Response
 */
export interface AuthControllerLeaveBusiness200Response {
    /**
     * 
     * @type {object}
     * @memberof AuthControllerLeaveBusiness200Response
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLeaveBusiness200Response
     */
    'status': AuthControllerLeaveBusiness200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLeaveBusiness200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLeaveBusiness200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof AuthControllerLeaveBusiness200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLeaveBusiness200Response
     */
    'messageCode'?: string;
}

export const AuthControllerLeaveBusiness200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type AuthControllerLeaveBusiness200ResponseStatusEnum = typeof AuthControllerLeaveBusiness200ResponseStatusEnum[keyof typeof AuthControllerLeaveBusiness200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface AuthControllerLoginWithPassword200Response
 */
export interface AuthControllerLoginWithPassword200Response {
    /**
     * 
     * @type {AuthResponseDto}
     * @memberof AuthControllerLoginWithPassword200Response
     */
    'data': AuthResponseDto;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLoginWithPassword200Response
     */
    'status': AuthControllerLoginWithPassword200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLoginWithPassword200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLoginWithPassword200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof AuthControllerLoginWithPassword200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLoginWithPassword200Response
     */
    'messageCode'?: string;
}

export const AuthControllerLoginWithPassword200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type AuthControllerLoginWithPassword200ResponseStatusEnum = typeof AuthControllerLoginWithPassword200ResponseStatusEnum[keyof typeof AuthControllerLoginWithPassword200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface AuthResponseDto
 */
export interface AuthResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AuthResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @enum {number}
 */

export const BIZUSERROLE = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type BIZUSERROLE = typeof BIZUSERROLE[keyof typeof BIZUSERROLE];


/**
 * 
 * @export
 * @enum {number}
 */

export const BUSINESSTYPE = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type BUSINESSTYPE = typeof BUSINESSTYPE[keyof typeof BUSINESSTYPE];


/**
 * 
 * @export
 * @interface BizDto
 */
export interface BizDto {
    /**
     * 
     * @type {number}
     * @memberof BizDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BizDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BizDto
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof BizDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof BizDto
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof BizDto
     */
    'role': number;
}
/**
 * 
 * @export
 * @interface BizUserControllerList200Response
 */
export interface BizUserControllerList200Response {
    /**
     * 
     * @type {Pagination}
     * @memberof BizUserControllerList200Response
     */
    'data': Pagination;
    /**
     * 
     * @type {string}
     * @memberof BizUserControllerList200Response
     */
    'status': BizUserControllerList200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BizUserControllerList200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BizUserControllerList200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof BizUserControllerList200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof BizUserControllerList200Response
     */
    'messageCode'?: string;
}

export const BizUserControllerList200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type BizUserControllerList200ResponseStatusEnum = typeof BizUserControllerList200ResponseStatusEnum[keyof typeof BizUserControllerList200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface BizViewDetailDto
 */
export interface BizViewDetailDto {
    /**
     * 
     * @type {number}
     * @memberof BizViewDetailDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BizViewDetailDto
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof BizViewDetailDto
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof BizViewDetailDto
     */
    'userFullName': string;
    /**
     * 
     * @type {string}
     * @memberof BizViewDetailDto
     */
    'userPhone': string;
    /**
     * pending: 1, accepted: 2, rejected: 3, cancelled: 4
     * @type {number}
     * @memberof BizViewDetailDto
     */
    'status': BizViewDetailDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BizViewDetailDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BizViewDetailDto
     */
    'createdBy': string;
}

export const BizViewDetailDtoStatusEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type BizViewDetailDtoStatusEnum = typeof BizViewDetailDtoStatusEnum[keyof typeof BizViewDetailDtoStatusEnum];

/**
 * 
 * @export
 * @interface BusinessControllerCreateBusiness200Response
 */
export interface BusinessControllerCreateBusiness200Response {
    /**
     * 
     * @type {CreateBusinessResponseDto}
     * @memberof BusinessControllerCreateBusiness200Response
     */
    'data': CreateBusinessResponseDto;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerCreateBusiness200Response
     */
    'status': BusinessControllerCreateBusiness200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerCreateBusiness200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerCreateBusiness200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof BusinessControllerCreateBusiness200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerCreateBusiness200Response
     */
    'messageCode'?: string;
}

export const BusinessControllerCreateBusiness200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type BusinessControllerCreateBusiness200ResponseStatusEnum = typeof BusinessControllerCreateBusiness200ResponseStatusEnum[keyof typeof BusinessControllerCreateBusiness200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface BusinessControllerGetBusinessList200Response
 */
export interface BusinessControllerGetBusinessList200Response {
    /**
     * 
     * @type {Array<BusinessItemDto>}
     * @memberof BusinessControllerGetBusinessList200Response
     */
    'data': Array<BusinessItemDto>;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerGetBusinessList200Response
     */
    'status': BusinessControllerGetBusinessList200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerGetBusinessList200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerGetBusinessList200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof BusinessControllerGetBusinessList200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerGetBusinessList200Response
     */
    'messageCode'?: string;
}

export const BusinessControllerGetBusinessList200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type BusinessControllerGetBusinessList200ResponseStatusEnum = typeof BusinessControllerGetBusinessList200ResponseStatusEnum[keyof typeof BusinessControllerGetBusinessList200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface BusinessControllerGetCurrentBusiness200Response
 */
export interface BusinessControllerGetCurrentBusiness200Response {
    /**
     * 
     * @type {DetailBusinessDto}
     * @memberof BusinessControllerGetCurrentBusiness200Response
     */
    'data': DetailBusinessDto;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerGetCurrentBusiness200Response
     */
    'status': BusinessControllerGetCurrentBusiness200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerGetCurrentBusiness200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerGetCurrentBusiness200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof BusinessControllerGetCurrentBusiness200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessControllerGetCurrentBusiness200Response
     */
    'messageCode'?: string;
}

export const BusinessControllerGetCurrentBusiness200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type BusinessControllerGetCurrentBusiness200ResponseStatusEnum = typeof BusinessControllerGetCurrentBusiness200ResponseStatusEnum[keyof typeof BusinessControllerGetCurrentBusiness200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface BusinessItemDto
 */
export interface BusinessItemDto {
    /**
     * 
     * @type {number}
     * @memberof BusinessItemDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof BusinessItemDto
     */
    'role': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof BusinessItemDto
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'addressFull': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'shortName': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'website': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessItemDto
     */
    'youtube': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CHECKSTAMPMODE = {
    Single: 'single',
    Range: 'range'
} as const;

export type CHECKSTAMPMODE = typeof CHECKSTAMPMODE[keyof typeof CHECKSTAMPMODE];


/**
 * 
 * @export
 * @enum {string}
 */

export const CHECKSTAMPTARGETSTATE = {
    Activation: 'activation',
    Retail: 'retail',
    Destroy: 'destroy'
} as const;

export type CHECKSTAMPTARGETSTATE = typeof CHECKSTAMPTARGETSTATE[keyof typeof CHECKSTAMPTARGETSTATE];


/**
 * 
 * @export
 * @enum {string}
 */

export const CHECKSTAMPTYPE = {
    Code: 'code',
    BizCountNumber: 'bizCountNumber'
} as const;

export type CHECKSTAMPTYPE = typeof CHECKSTAMPTYPE[keyof typeof CHECKSTAMPTYPE];


/**
 * 
 * @export
 * @interface ChangeBusinessDto
 */
export interface ChangeBusinessDto {
    /**
     * 
     * @type {number}
     * @memberof ChangeBusinessDto
     */
    'bizId': number;
}
/**
 * 
 * @export
 * @interface ChangeRoleDto
 */
export interface ChangeRoleDto {
    /**
     * 
     * @type {number}
     * @memberof ChangeRoleDto
     */
    'bizUserId': number;
    /**
     * 1: Owner, 2: User
     * @type {BIZUSERROLE}
     * @memberof ChangeRoleDto
     */
    'role': BIZUSERROLE;
}


/**
 * 
 * @export
 * @interface CheckStampDto
 */
export interface CheckStampDto {
    /**
     * 
     * @type {CHECKSTAMPMODE}
     * @memberof CheckStampDto
     */
    'mode': CHECKSTAMPMODE;
    /**
     * 
     * @type {CHECKSTAMPTYPE}
     * @memberof CheckStampDto
     */
    'type': CHECKSTAMPTYPE;
    /**
     * 
     * @type {CHECKSTAMPTARGETSTATE}
     * @memberof CheckStampDto
     */
    'targetState': CHECKSTAMPTARGETSTATE;
    /**
     * Stamp codes or bizCountNumber, required when mode is single
     * @type {Array<string>}
     * @memberof CheckStampDto
     */
    'codes': Array<string>;
    /**
     * Stamp range start, required when mode is range
     * @type {string}
     * @memberof CheckStampDto
     */
    'start': string;
    /**
     * Stamp range end, required when mode is range
     * @type {string}
     * @memberof CheckStampDto
     */
    'end': string;
}


/**
 * 
 * @export
 * @interface CheckStampResponseDto
 */
export interface CheckStampResponseDto {
    /**
     * 
     * @type {number}
     * @memberof CheckStampResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof CheckStampResponseDto
     */
    'valid': number;
    /**
     * 
     * @type {number}
     * @memberof CheckStampResponseDto
     */
    'inValid': number;
    /**
     * 
     * @type {Array<CheckStampResponseItemDto>}
     * @memberof CheckStampResponseDto
     */
    'items': Array<CheckStampResponseItemDto>;
}
/**
 * 
 * @export
 * @interface CheckStampResponseItemDto
 */
export interface CheckStampResponseItemDto {
    /**
     * 
     * @type {string}
     * @memberof CheckStampResponseItemDto
     */
    'bizStampId': string;
    /**
     * 
     * @type {string}
     * @memberof CheckStampResponseItemDto
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof CheckStampResponseItemDto
     */
    'number': number;
    /**
     * 
     * @type {boolean}
     * @memberof CheckStampResponseItemDto
     */
    'isValid': boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckStampResponseItemDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CloneFileDto
 */
export interface CloneFileDto {
    /**
     * The urls of files to clone.
     * @type {Array<string>}
     * @memberof CloneFileDto
     */
    'urls': Array<string>;
}
/**
 * 
 * @export
 * @interface CloneFileItemDto
 */
export interface CloneFileItemDto {
    /**
     * 
     * @type {string}
     * @memberof CloneFileItemDto
     */
    'fromUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CloneFileItemDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CloneFileItemDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CloneFileResponseDto
 */
export interface CloneFileResponseDto {
    /**
     * 
     * @type {Array<CloneFileItemDto>}
     * @memberof CloneFileResponseDto
     */
    'items': Array<CloneFileItemDto>;
}
/**
 * 
 * @export
 * @interface CreateActivationDocDto
 */
export interface CreateActivationDocDto {
    /**
     * 
     * @type {number}
     * @memberof CreateActivationDocDto
     */
    'productId': number;
    /**
     * Activation attributes
     * @type {Array<CreateActivationProductAttributeDto>}
     * @memberof CreateActivationDocDto
     */
    'activationAttributes': Array<CreateActivationProductAttributeDto>;
    /**
     * biz stamp ids, It return from check stamp API
     * @type {Array<string>}
     * @memberof CreateActivationDocDto
     */
    'bizStampIds': Array<string>;
    /**
     * Activation note
     * @type {string}
     * @memberof CreateActivationDocDto
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface CreateActivationProductAttributeDto
 */
export interface CreateActivationProductAttributeDto {
    /**
     * 
     * @type {number}
     * @memberof CreateActivationProductAttributeDto
     */
    'attributeId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateActivationProductAttributeDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateBusinessResponseDto
 */
export interface CreateBusinessResponseDto {
    /**
     * 
     * @type {number}
     * @memberof CreateBusinessResponseDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface CreateDestructionDto
 */
export interface CreateDestructionDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDestructionDto
     */
    'note': string;
    /**
     * biz stamp ids, It return from check stamp API
     * @type {Array<string>}
     * @memberof CreateDestructionDto
     */
    'bizStampIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateGenerationDocDto
 */
export interface CreateGenerationDocDto {
    /**
     * 
     * @type {number}
     * @memberof CreateGenerationDocDto
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof CreateGenerationDocDto
     */
    'stampTemplateId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateGenerationDocDto
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface CreateInvitationDto
 */
export interface CreateInvitationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateInvitationDto
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface CreateInvitationResponseDto
 */
export interface CreateInvitationResponseDto {
    /**
     *         valid means this phone is valid and an invitation was sent to this phone,        not-found means this phone not found,         waiting-confirm means user has not confirmed the invitation,         rejected means user has rejected the invitation,         cancelled means the invitation has been cancelled,         active means user has confirmed the invitation and now is active,         inactive means has confirmed the invitation but now is inactive
     * @type {InvitationStatus}
     * @memberof CreateInvitationResponseDto
     */
    'status': InvitationStatus;
    /**
     * 
     * @type {string}
     * @memberof CreateInvitationResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateInvitationResponseDto
     */
    'phone': string;
    /**
     * 
     * @type {number}
     * @memberof CreateInvitationResponseDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateInvitationResponseDto
     */
    'invitationId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateInvitationResponseDto
     */
    'invitationCode': string;
}


/**
 * 
 * @export
 * @interface CreatePreactiveDocDto
 */
export interface CreatePreactiveDocDto {
    /**
     * 
     * @type {number}
     * @memberof CreatePreactiveDocDto
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof CreatePreactiveDocDto
     */
    'stampTemplateId': number;
    /**
     * 
     * @type {number}
     * @memberof CreatePreactiveDocDto
     */
    'productId': number;
    /**
     * Activation attributes
     * @type {Array<CreateActivationProductAttributeDto>}
     * @memberof CreatePreactiveDocDto
     */
    'activationAttributes': Array<CreateActivationProductAttributeDto>;
    /**
     * 
     * @type {string}
     * @memberof CreatePreactiveDocDto
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface CreateProductAttributeDto
 */
export interface CreateProductAttributeDto {
    /**
     * 1: Product, 2: Activation, 3: Sale
     * @type {PRODUCTATTRIBUTETYPE}
     * @memberof CreateProductAttributeDto
     */
    'type': PRODUCTATTRIBUTETYPE;
    /**
     * 
     * @type {string}
     * @memberof CreateProductAttributeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductAttributeDto
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductAttributeDto
     */
    'unit': string;
}


/**
 * 
 * @export
 * @interface CreateProductDto
 */
export interface CreateProductDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateProductDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'gtin': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'hsCode': string;
    /**
     * 
     * @type {number}
     * @memberof CreateProductDto
     */
    'autoActivationSeconds': number;
    /**
     * 
     * @type {number}
     * @memberof CreateProductDto
     */
    'autoSaleSeconds': number;
    /**
     * 
     * @type {number}
     * @memberof CreateProductDto
     */
    'autoExpireSeconds': number;
    /**
     * 1: Hours, 2: Days, 3: Weeks, 4: Months
     * @type {PRODUCTEXPIREEXCHANGEUNIT}
     * @memberof CreateProductDto
     */
    'autoExpireExchangeUnit': PRODUCTEXPIREEXCHANGEUNIT;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'youtubeLink': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductDto
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateProductDto
     */
    'slideImages': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateProductDto
     */
    'introImages': Array<string>;
    /**
     * 
     * @type {Array<CreateProductAttributeDto>}
     * @memberof CreateProductDto
     */
    'attributes': Array<CreateProductAttributeDto>;
}


/**
 * 
 * @export
 * @interface CreateRetailDto
 */
export interface CreateRetailDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRetailDto
     */
    'note': string;
    /**
     * biz stamp ids, It return from check stamp API
     * @type {Array<string>}
     * @memberof CreateRetailDto
     */
    'bizStampIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateStampTemplateDto
 */
export interface CreateStampTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof CreateStampTemplateDto
     */
    'name': string;
    /**
     * 15x15-6, 25x15-4, 35x22-3, 46x34-2, 15x15-4, 20x20-3, 30x30-2, 25x15-3, 35x22-2
     * @type {STAMPTEMPLATESIZE}
     * @memberof CreateStampTemplateDto
     */
    'size': STAMPTEMPLATESIZE;
    /**
     * 
     * @type {string}
     * @memberof CreateStampTemplateDto
     */
    'topText': string;
    /**
     * 
     * @type {string}
     * @memberof CreateStampTemplateDto
     */
    'bottomText': string;
    /**
     * 
     * @type {string}
     * @memberof CreateStampTemplateDto
     */
    'centerText': string;
    /**
     * 1: use image, 2: use date
     * @type {STAMPTEMPLATEDISPLAYMODE}
     * @memberof CreateStampTemplateDto
     */
    'displayMode': STAMPTEMPLATEDISPLAYMODE;
    /**
     * 
     * @type {string}
     * @memberof CreateStampTemplateDto
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof CreateStampTemplateDto
     */
    'useExpiredDate': number;
    /**
     * 
     * @type {number}
     * @memberof CreateStampTemplateDto
     */
    'useActivationDate': number;
}


/**
 * 
 * @export
 * @interface CurrentUserDto
 */
export interface CurrentUserDto {
    /**
     * 
     * @type {number}
     * @memberof CurrentUserDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CurrentUserDto
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'full_name': string;
    /**
     * 
     * @type {number}
     * @memberof CurrentUserDto
     */
    'gender': number | null;
    /**
     * 
     * @type {number}
     * @memberof CurrentUserDto
     */
    'province_code': number | null;
    /**
     * 
     * @type {number}
     * @memberof CurrentUserDto
     */
    'district_code': number | null;
    /**
     * 
     * @type {number}
     * @memberof CurrentUserDto
     */
    'ward_code': number | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'address_detail': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'address_full': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'avatar': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'date_of_birth': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'identification_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'identification_issued_place': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'identification_issued_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'biz_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'biz_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'biz_logo': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'biz_phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserDto
     */
    'biz_address': string | null;
    /**
     * 
     * @type {number}
     * @memberof CurrentUserDto
     */
    'biz_role': number | null;
    /**
     * 
     * @type {Array<BizDto>}
     * @memberof CurrentUserDto
     */
    'managed_bizs': Array<BizDto>;
}
/**
 * 
 * @export
 * @interface DestructionControllerCreate200Response
 */
export interface DestructionControllerCreate200Response {
    /**
     * 
     * @type {DetailDestructionDto}
     * @memberof DestructionControllerCreate200Response
     */
    'data': DetailDestructionDto;
    /**
     * 
     * @type {string}
     * @memberof DestructionControllerCreate200Response
     */
    'status': DestructionControllerCreate200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DestructionControllerCreate200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof DestructionControllerCreate200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof DestructionControllerCreate200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof DestructionControllerCreate200Response
     */
    'messageCode'?: string;
}

export const DestructionControllerCreate200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type DestructionControllerCreate200ResponseStatusEnum = typeof DestructionControllerCreate200ResponseStatusEnum[keyof typeof DestructionControllerCreate200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface DetailActivationDocDto
 */
export interface DetailActivationDocDto {
    /**
     * 
     * @type {number}
     * @memberof DetailActivationDocDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DetailActivationDocDto
     */
    'productId': number;
    /**
     * 
     * @type {string}
     * @memberof DetailActivationDocDto
     */
    'productName': string;
    /**
     * 
     * @type {number}
     * @memberof DetailActivationDocDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof DetailActivationDocDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DetailActivationDocDto
     */
    'createdBy': string;
    /**
     * 
     * @type {Array<DetailActivationDocStampDto>}
     * @memberof DetailActivationDocDto
     */
    'stamps': Array<DetailActivationDocStampDto>;
}
/**
 * 
 * @export
 * @interface DetailActivationDocStampDto
 */
export interface DetailActivationDocStampDto {
    /**
     * 
     * @type {number}
     * @memberof DetailActivationDocStampDto
     */
    'bizStampId': number;
    /**
     * 
     * @type {number}
     * @memberof DetailActivationDocStampDto
     */
    'stampId': number;
    /**
     * 
     * @type {string}
     * @memberof DetailActivationDocStampDto
     */
    'stampCode': string;
    /**
     * 
     * @type {number}
     * @memberof DetailActivationDocStampDto
     */
    'number': number;
}
/**
 * 
 * @export
 * @interface DetailBusinessDto
 */
export interface DetailBusinessDto {
    /**
     * 
     * @type {number}
     * @memberof DetailBusinessDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DetailBusinessDto
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'gcp': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'taxCode': string;
    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'businessRegistrationIssuedDate': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'businessRegistrationIssuedPlace': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'provinceCode': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'districtCode': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'wardCode': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'addressDetail': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'addressFull': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'shortName': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'website': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'youtube': string;
    /**
     * 
     * @type {string}
     * @memberof DetailBusinessDto
     */
    'createdBy': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DetailBusinessDto
     */
    'slideImages': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DetailBusinessDto
     */
    'introImages': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DetailBusinessDto
     */
    'businessRegistrationScans': Array<string>;
}
/**
 * 
 * @export
 * @interface DetailDestructionDto
 */
export interface DetailDestructionDto {
    /**
     * 
     * @type {number}
     * @memberof DetailDestructionDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DetailDestructionDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof DetailDestructionDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DetailDestructionDto
     */
    'createdBy': string;
    /**
     * 
     * @type {Array<DetailDestructionStampDto>}
     * @memberof DetailDestructionDto
     */
    'stamps': Array<DetailDestructionStampDto>;
}
/**
 * 
 * @export
 * @interface DetailDestructionStampDto
 */
export interface DetailDestructionStampDto {
    /**
     * 
     * @type {number}
     * @memberof DetailDestructionStampDto
     */
    'bizStampId': number;
    /**
     * 
     * @type {number}
     * @memberof DetailDestructionStampDto
     */
    'stampId': number;
    /**
     * 
     * @type {string}
     * @memberof DetailDestructionStampDto
     */
    'stampCode': string;
    /**
     * 
     * @type {number}
     * @memberof DetailDestructionStampDto
     */
    'skuId': number;
    /**
     * 
     * @type {number}
     * @memberof DetailDestructionStampDto
     */
    'productId': number;
    /**
     * 
     * @type {string}
     * @memberof DetailDestructionStampDto
     */
    'productName': string;
}
/**
 * 
 * @export
 * @interface DetailGenerationDocDto
 */
export interface DetailGenerationDocDto {
    /**
     * 
     * @type {number}
     * @memberof DetailGenerationDocDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DetailGenerationDocDto
     */
    'templateId': number;
    /**
     * 
     * @type {string}
     * @memberof DetailGenerationDocDto
     */
    'templateName': string;
    /**
     * 
     * @type {number}
     * @memberof DetailGenerationDocDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof DetailGenerationDocDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DetailGenerationDocDto
     */
    'createdBy': string;
    /**
     * 
     * @type {Array<DetailGenerationDocStampDto>}
     * @memberof DetailGenerationDocDto
     */
    'stamps': Array<DetailGenerationDocStampDto>;
}
/**
 * 
 * @export
 * @interface DetailGenerationDocStampDto
 */
export interface DetailGenerationDocStampDto {
    /**
     * 
     * @type {number}
     * @memberof DetailGenerationDocStampDto
     */
    'stampId': number;
    /**
     * 
     * @type {string}
     * @memberof DetailGenerationDocStampDto
     */
    'stampCode': string;
    /**
     * 
     * @type {number}
     * @memberof DetailGenerationDocStampDto
     */
    'number': number;
}
/**
 * 
 * @export
 * @interface DetailRetailOrderDto
 */
export interface DetailRetailOrderDto {
    /**
     * 
     * @type {number}
     * @memberof DetailRetailOrderDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DetailRetailOrderDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof DetailRetailOrderDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DetailRetailOrderDto
     */
    'createdBy': string;
    /**
     * 
     * @type {Array<DetailRetailOrderStampDto>}
     * @memberof DetailRetailOrderDto
     */
    'stamps': Array<DetailRetailOrderStampDto>;
}
/**
 * 
 * @export
 * @interface DetailRetailOrderStampDto
 */
export interface DetailRetailOrderStampDto {
    /**
     * 
     * @type {number}
     * @memberof DetailRetailOrderStampDto
     */
    'bizStampId': number;
    /**
     * 
     * @type {number}
     * @memberof DetailRetailOrderStampDto
     */
    'stampId': number;
    /**
     * 
     * @type {string}
     * @memberof DetailRetailOrderStampDto
     */
    'stampCode': string;
    /**
     * 
     * @type {number}
     * @memberof DetailRetailOrderStampDto
     */
    'skuId': number;
    /**
     * 
     * @type {number}
     * @memberof DetailRetailOrderStampDto
     */
    'productId': number;
    /**
     * 
     * @type {string}
     * @memberof DetailRetailOrderStampDto
     */
    'productName': string;
}
/**
 * 
 * @export
 * @interface FileUploadResponseDto
 */
export interface FileUploadResponseDto {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponseDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponseDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GenerationControllerGenerateStamp200Response
 */
export interface GenerationControllerGenerateStamp200Response {
    /**
     * 
     * @type {DetailGenerationDocDto}
     * @memberof GenerationControllerGenerateStamp200Response
     */
    'data': DetailGenerationDocDto;
    /**
     * 
     * @type {string}
     * @memberof GenerationControllerGenerateStamp200Response
     */
    'status': GenerationControllerGenerateStamp200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GenerationControllerGenerateStamp200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerationControllerGenerateStamp200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof GenerationControllerGenerateStamp200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof GenerationControllerGenerateStamp200Response
     */
    'messageCode'?: string;
}

export const GenerationControllerGenerateStamp200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type GenerationControllerGenerateStamp200ResponseStatusEnum = typeof GenerationControllerGenerateStamp200ResponseStatusEnum[keyof typeof GenerationControllerGenerateStamp200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GenerationControllerGetPrintUrl200Response
 */
export interface GenerationControllerGetPrintUrl200Response {
    /**
     * 
     * @type {PrintUrlDto}
     * @memberof GenerationControllerGetPrintUrl200Response
     */
    'data': PrintUrlDto;
    /**
     * 
     * @type {string}
     * @memberof GenerationControllerGetPrintUrl200Response
     */
    'status': GenerationControllerGetPrintUrl200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GenerationControllerGetPrintUrl200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerationControllerGetPrintUrl200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof GenerationControllerGetPrintUrl200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof GenerationControllerGetPrintUrl200Response
     */
    'messageCode'?: string;
}

export const GenerationControllerGetPrintUrl200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type GenerationControllerGetPrintUrl200ResponseStatusEnum = typeof GenerationControllerGetPrintUrl200ResponseStatusEnum[keyof typeof GenerationControllerGetPrintUrl200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetZaloLoginUrlResponseDto
 */
export interface GetZaloLoginUrlResponseDto {
    /**
     * 
     * @type {string}
     * @memberof GetZaloLoginUrlResponseDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface InvitationControllerCreate200Response
 */
export interface InvitationControllerCreate200Response {
    /**
     * 
     * @type {CreateInvitationResponseDto}
     * @memberof InvitationControllerCreate200Response
     */
    'data': CreateInvitationResponseDto;
    /**
     * 
     * @type {string}
     * @memberof InvitationControllerCreate200Response
     */
    'status': InvitationControllerCreate200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InvitationControllerCreate200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvitationControllerCreate200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof InvitationControllerCreate200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof InvitationControllerCreate200Response
     */
    'messageCode'?: string;
}

export const InvitationControllerCreate200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type InvitationControllerCreate200ResponseStatusEnum = typeof InvitationControllerCreate200ResponseStatusEnum[keyof typeof InvitationControllerCreate200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface InvitationControllerFindOne200Response
 */
export interface InvitationControllerFindOne200Response {
    /**
     * 
     * @type {BizViewDetailDto}
     * @memberof InvitationControllerFindOne200Response
     */
    'data': BizViewDetailDto;
    /**
     * 
     * @type {string}
     * @memberof InvitationControllerFindOne200Response
     */
    'status': InvitationControllerFindOne200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InvitationControllerFindOne200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvitationControllerFindOne200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof InvitationControllerFindOne200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof InvitationControllerFindOne200Response
     */
    'messageCode'?: string;
}

export const InvitationControllerFindOne200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type InvitationControllerFindOne200ResponseStatusEnum = typeof InvitationControllerFindOne200ResponseStatusEnum[keyof typeof InvitationControllerFindOne200ResponseStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const InvitationStatus = {
    Valid: 'valid',
    NotFound: 'not-found',
    WaitingConfirm: 'waiting-confirm',
    Rejected: 'rejected',
    Cancelled: 'cancelled',
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type InvitationStatus = typeof InvitationStatus[keyof typeof InvitationStatus];


/**
 * 
 * @export
 * @interface ListActivationDocItemDto
 */
export interface ListActivationDocItemDto {
    /**
     * 
     * @type {number}
     * @memberof ListActivationDocItemDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ListActivationDocItemDto
     */
    'productId': number;
    /**
     * 
     * @type {string}
     * @memberof ListActivationDocItemDto
     */
    'productName': string;
    /**
     * 
     * @type {number}
     * @memberof ListActivationDocItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof ListActivationDocItemDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ListActivationDocItemDto
     */
    'createdBy': string;
}
/**
 * 
 * @export
 * @interface ListBizUserItemDto
 */
export interface ListBizUserItemDto {
    /**
     * 
     * @type {number}
     * @memberof ListBizUserItemDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ListBizUserItemDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof ListBizUserItemDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ListBizUserItemDto
     */
    'phone': string;
    /**
     * 
     * @type {number}
     * @memberof ListBizUserItemDto
     */
    'status': number;
    /**
     * 
     * @type {number}
     * @memberof ListBizUserItemDto
     */
    'role': number;
    /**
     * 
     * @type {string}
     * @memberof ListBizUserItemDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ListBizUserItemDto
     */
    'createdBy': string;
}
/**
 * 
 * @export
 * @interface ListDestructionItemDto
 */
export interface ListDestructionItemDto {
    /**
     * 
     * @type {number}
     * @memberof ListDestructionItemDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ListDestructionItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof ListDestructionItemDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ListDestructionItemDto
     */
    'createdBy': string;
}
/**
 * 
 * @export
 * @interface ListGenerationDocItemDto
 */
export interface ListGenerationDocItemDto {
    /**
     * 
     * @type {number}
     * @memberof ListGenerationDocItemDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ListGenerationDocItemDto
     */
    'templateId': number;
    /**
     * 
     * @type {string}
     * @memberof ListGenerationDocItemDto
     */
    'templateName': string;
    /**
     * 
     * @type {number}
     * @memberof ListGenerationDocItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof ListGenerationDocItemDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ListGenerationDocItemDto
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof ListGenerationDocItemDto
     */
    'printUrl': string;
}
/**
 * 
 * @export
 * @interface ListInvitationItemDto
 */
export interface ListInvitationItemDto {
    /**
     * 
     * @type {number}
     * @memberof ListInvitationItemDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ListInvitationItemDto
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof ListInvitationItemDto
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof ListInvitationItemDto
     */
    'userFullName': string;
    /**
     * 
     * @type {string}
     * @memberof ListInvitationItemDto
     */
    'userPhone': string;
    /**
     * 
     * @type {number}
     * @memberof ListInvitationItemDto
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof ListInvitationItemDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ListInvitationItemDto
     */
    'createdBy': string;
}
/**
 * 
 * @export
 * @interface ListMyInvitationItemDto
 */
export interface ListMyInvitationItemDto {
    /**
     * 
     * @type {number}
     * @memberof ListMyInvitationItemDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ListMyInvitationItemDto
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof ListMyInvitationItemDto
     */
    'bizId': number;
    /**
     * 
     * @type {string}
     * @memberof ListMyInvitationItemDto
     */
    'bizName': string;
    /**
     * 
     * @type {string}
     * @memberof ListMyInvitationItemDto
     */
    'bizCode': string;
    /**
     * 
     * @type {string}
     * @memberof ListMyInvitationItemDto
     */
    'bizLogo': string;
    /**
     * 
     * @type {string}
     * @memberof ListMyInvitationItemDto
     */
    'bizPhone': string;
    /**
     * 
     * @type {string}
     * @memberof ListMyInvitationItemDto
     */
    'bizAddress': string;
    /**
     * pending: 1, accepted: 2, rejected: 3, cancelled: 4
     * @type {number}
     * @memberof ListMyInvitationItemDto
     */
    'status': ListMyInvitationItemDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ListMyInvitationItemDto
     */
    'createdAt': string;
}

export const ListMyInvitationItemDtoStatusEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type ListMyInvitationItemDtoStatusEnum = typeof ListMyInvitationItemDtoStatusEnum[keyof typeof ListMyInvitationItemDtoStatusEnum];

/**
 * 
 * @export
 * @interface ListRetailOrderItemDto
 */
export interface ListRetailOrderItemDto {
    /**
     * 
     * @type {number}
     * @memberof ListRetailOrderItemDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ListRetailOrderItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof ListRetailOrderItemDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ListRetailOrderItemDto
     */
    'createdBy': string;
}
/**
 * 
 * @export
 * @interface LocationControllerGetProvinces200Response
 */
export interface LocationControllerGetProvinces200Response {
    /**
     * 
     * @type {Array<AddressItemDto>}
     * @memberof LocationControllerGetProvinces200Response
     */
    'data': Array<AddressItemDto>;
    /**
     * 
     * @type {string}
     * @memberof LocationControllerGetProvinces200Response
     */
    'status': LocationControllerGetProvinces200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof LocationControllerGetProvinces200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationControllerGetProvinces200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof LocationControllerGetProvinces200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof LocationControllerGetProvinces200Response
     */
    'messageCode'?: string;
}

export const LocationControllerGetProvinces200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type LocationControllerGetProvinces200ResponseStatusEnum = typeof LocationControllerGetProvinces200ResponseStatusEnum[keyof typeof LocationControllerGetProvinces200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface LoginWithPasswordDto
 */
export interface LoginWithPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof LoginWithPasswordDto
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof LoginWithPasswordDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginWithZaloDto
 */
export interface LoginWithZaloDto {
    /**
     * 
     * @type {string}
     * @memberof LoginWithZaloDto
     */
    'authorization_code': string;
    /**
     * 
     * @type {string}
     * @memberof LoginWithZaloDto
     */
    'code_challenge': string;
}
/**
 * 
 * @export
 * @interface MyInvitationControllerFindOne200Response
 */
export interface MyInvitationControllerFindOne200Response {
    /**
     * 
     * @type {MyInvitationDetailDto}
     * @memberof MyInvitationControllerFindOne200Response
     */
    'data': MyInvitationDetailDto;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationControllerFindOne200Response
     */
    'status': MyInvitationControllerFindOne200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationControllerFindOne200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationControllerFindOne200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof MyInvitationControllerFindOne200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationControllerFindOne200Response
     */
    'messageCode'?: string;
}

export const MyInvitationControllerFindOne200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type MyInvitationControllerFindOne200ResponseStatusEnum = typeof MyInvitationControllerFindOne200ResponseStatusEnum[keyof typeof MyInvitationControllerFindOne200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface MyInvitationControllerSearch200Response
 */
export interface MyInvitationControllerSearch200Response {
    /**
     * 
     * @type {Array<ListMyInvitationItemDto>}
     * @memberof MyInvitationControllerSearch200Response
     */
    'data': Array<ListMyInvitationItemDto>;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationControllerSearch200Response
     */
    'status': MyInvitationControllerSearch200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationControllerSearch200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationControllerSearch200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof MyInvitationControllerSearch200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationControllerSearch200Response
     */
    'messageCode'?: string;
}

export const MyInvitationControllerSearch200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type MyInvitationControllerSearch200ResponseStatusEnum = typeof MyInvitationControllerSearch200ResponseStatusEnum[keyof typeof MyInvitationControllerSearch200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface MyInvitationDetailDto
 */
export interface MyInvitationDetailDto {
    /**
     * 
     * @type {number}
     * @memberof MyInvitationDetailDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationDetailDto
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationDetailDto
     */
    'bizName': string;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationDetailDto
     */
    'bizCode': string;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationDetailDto
     */
    'bizLogo': string;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationDetailDto
     */
    'bizPhone': string;
    /**
     * pending: 1, accepted: 2, rejected: 3, cancelled: 4
     * @type {number}
     * @memberof MyInvitationDetailDto
     */
    'status': MyInvitationDetailDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof MyInvitationDetailDto
     */
    'createdAt': string;
}

export const MyInvitationDetailDtoStatusEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type MyInvitationDetailDtoStatusEnum = typeof MyInvitationDetailDtoStatusEnum[keyof typeof MyInvitationDetailDtoStatusEnum];

/**
 * 
 * @export
 * @enum {number}
 */

export const PRODUCTATTRIBUTETYPE = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type PRODUCTATTRIBUTETYPE = typeof PRODUCTATTRIBUTETYPE[keyof typeof PRODUCTATTRIBUTETYPE];


/**
 * 
 * @export
 * @enum {number}
 */

export const PRODUCTEXPIREEXCHANGEUNIT = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type PRODUCTEXPIREEXCHANGEUNIT = typeof PRODUCTEXPIREEXCHANGEUNIT[keyof typeof PRODUCTEXPIREEXCHANGEUNIT];


/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {Array<object>}
     * @memberof Pagination
     */
    'items': Array<object>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof Pagination
     */
    'pagination': PaginationInfo;
}
/**
 * 
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
    /**
     * 
     * @type {number}
     * @memberof PaginationInfo
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationInfo
     */
    'perpage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationInfo
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationInfo
     */
    'totalItems': number;
}
/**
 * 
 * @export
 * @interface PrintUrlDto
 */
export interface PrintUrlDto {
    /**
     * 
     * @type {string}
     * @memberof PrintUrlDto
     */
    'printUrl': string;
}
/**
 * 
 * @export
 * @interface ProductAttributeDto
 */
export interface ProductAttributeDto {
    /**
     * 
     * @type {number}
     * @memberof ProductAttributeDto
     */
    'id': number;
    /**
     * PRODUCT: 1, ACTIVATION: 2, SALE: 3
     * @type {PRODUCTATTRIBUTETYPE}
     * @memberof ProductAttributeDto
     */
    'type': PRODUCTATTRIBUTETYPE;
    /**
     * 
     * @type {string}
     * @memberof ProductAttributeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductAttributeDto
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ProductAttributeDto
     */
    'unit': string;
    /**
     * 
     * @type {number}
     * @memberof ProductAttributeDto
     */
    'isRequired': number;
}


/**
 * 
 * @export
 * @interface ProductControllerCreate200Response
 */
export interface ProductControllerCreate200Response {
    /**
     * 
     * @type {ProductDetailDto}
     * @memberof ProductControllerCreate200Response
     */
    'data': ProductDetailDto;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerCreate200Response
     */
    'status': ProductControllerCreate200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerCreate200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerCreate200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof ProductControllerCreate200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerCreate200Response
     */
    'messageCode'?: string;
}

export const ProductControllerCreate200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type ProductControllerCreate200ResponseStatusEnum = typeof ProductControllerCreate200ResponseStatusEnum[keyof typeof ProductControllerCreate200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ProductControllerFindAllActive200Response
 */
export interface ProductControllerFindAllActive200Response {
    /**
     * 
     * @type {Array<ProductListActiveItemDto>}
     * @memberof ProductControllerFindAllActive200Response
     */
    'data': Array<ProductListActiveItemDto>;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerFindAllActive200Response
     */
    'status': ProductControllerFindAllActive200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerFindAllActive200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerFindAllActive200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof ProductControllerFindAllActive200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerFindAllActive200Response
     */
    'messageCode'?: string;
}

export const ProductControllerFindAllActive200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type ProductControllerFindAllActive200ResponseStatusEnum = typeof ProductControllerFindAllActive200ResponseStatusEnum[keyof typeof ProductControllerFindAllActive200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ProductControllerFindAttributes200Response
 */
export interface ProductControllerFindAttributes200Response {
    /**
     * 
     * @type {Array<ProductAttributeDto>}
     * @memberof ProductControllerFindAttributes200Response
     */
    'data': Array<ProductAttributeDto>;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerFindAttributes200Response
     */
    'status': ProductControllerFindAttributes200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerFindAttributes200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerFindAttributes200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof ProductControllerFindAttributes200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof ProductControllerFindAttributes200Response
     */
    'messageCode'?: string;
}

export const ProductControllerFindAttributes200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type ProductControllerFindAttributes200ResponseStatusEnum = typeof ProductControllerFindAttributes200ResponseStatusEnum[keyof typeof ProductControllerFindAttributes200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ProductDetailDto
 */
export interface ProductDetailDto {
    /**
     * 
     * @type {number}
     * @memberof ProductDetailDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'publicCode': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'gtin': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'hsCode': string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailDto
     */
    'status': number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailDto
     */
    'autoActivationSeconds': number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailDto
     */
    'autoSaleSeconds': number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailDto
     */
    'autoExpireSeconds': number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailDto
     */
    'autoExpireExchangeUnit': number;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'youtubeLink': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailDto
     */
    'createdBy': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductDetailDto
     */
    'slideImages': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductDetailDto
     */
    'introImages': Array<string>;
    /**
     * 
     * @type {Array<ProductAttributeDto>}
     * @memberof ProductDetailDto
     */
    'attributes': Array<ProductAttributeDto>;
}
/**
 * 
 * @export
 * @interface ProductInfo
 */
export interface ProductInfo {
    /**
     * 
     * @type {number}
     * @memberof ProductInfo
     */
    'product_id': number;
    /**
     * 
     * @type {number}
     * @memberof ProductInfo
     */
    'sku_id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'public_code': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'gtin': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'hs_code': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'activation_datetime': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'expiration_datetime': string;
    /**
     * 
     * @type {Array<ProductAttributeDto>}
     * @memberof ProductInfo
     */
    'attributes': Array<ProductAttributeDto>;
}
/**
 * 
 * @export
 * @interface ProductListActiveItemDto
 */
export interface ProductListActiveItemDto {
    /**
     * 
     * @type {number}
     * @memberof ProductListActiveItemDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductListActiveItemDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListActiveItemDto
     */
    'gtin': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListActiveItemDto
     */
    'publicCode': string;
}
/**
 * 
 * @export
 * @interface ProductListItemDto
 */
export interface ProductListItemDto {
    /**
     * 
     * @type {number}
     * @memberof ProductListItemDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProductListItemDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListItemDto
     */
    'gtin': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListItemDto
     */
    'publicCode': string;
    /**
     * 
     * @type {number}
     * @memberof ProductListItemDto
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ProductListItemDto
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof ProductListItemDto
     */
    'hsCode': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListItemDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListItemDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProductListItemDto
     */
    'created_by': string;
}
/**
 * 
 * @export
 * @interface ResponseType
 */
export interface ResponseType {
    /**
     * 
     * @type {object}
     * @memberof ResponseType
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof ResponseType
     */
    'status': ResponseTypeStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ResponseType
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseType
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseType
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseType
     */
    'messageCode'?: string;
}

export const ResponseTypeStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type ResponseTypeStatusEnum = typeof ResponseTypeStatusEnum[keyof typeof ResponseTypeStatusEnum];

/**
 * 
 * @export
 * @interface RetailControllerCreate200Response
 */
export interface RetailControllerCreate200Response {
    /**
     * 
     * @type {DetailRetailOrderDto}
     * @memberof RetailControllerCreate200Response
     */
    'data': DetailRetailOrderDto;
    /**
     * 
     * @type {string}
     * @memberof RetailControllerCreate200Response
     */
    'status': RetailControllerCreate200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof RetailControllerCreate200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetailControllerCreate200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof RetailControllerCreate200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof RetailControllerCreate200Response
     */
    'messageCode'?: string;
}

export const RetailControllerCreate200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type RetailControllerCreate200ResponseStatusEnum = typeof RetailControllerCreate200ResponseStatusEnum[keyof typeof RetailControllerCreate200ResponseStatusEnum];

/**
 * 
 * @export
 * @enum {number}
 */

export const STAMPTEMPLATEDISPLAYMODE = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type STAMPTEMPLATEDISPLAYMODE = typeof STAMPTEMPLATEDISPLAYMODE[keyof typeof STAMPTEMPLATEDISPLAYMODE];


/**
 * 
 * @export
 * @enum {string}
 */

export const STAMPTEMPLATESIZE = {
    _15x156: '15x15-6',
    _25x154: '25x15-4',
    _35x223: '35x22-3',
    _46x342: '46x34-2',
    _15x154: '15x15-4',
    _20x203: '20x20-3',
    _30x302: '30x30-2',
    _25x153: '25x15-3',
    _35x222: '35x22-2'
} as const;

export type STAMPTEMPLATESIZE = typeof STAMPTEMPLATESIZE[keyof typeof STAMPTEMPLATESIZE];


/**
 * 
 * @export
 * @enum {number}
 */

export const STAMPTEMPLATESTATUS = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type STAMPTEMPLATESTATUS = typeof STAMPTEMPLATESTATUS[keyof typeof STAMPTEMPLATESTATUS];


/**
 * 
 * @export
 * @interface SignUpWithPasswordDto
 */
export interface SignUpWithPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpWithPasswordDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpWithPasswordDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpWithPasswordDto
     */
    'passwordConfirm': string;
}
/**
 * 
 * @export
 * @interface StampControllerCheckStamp200Response
 */
export interface StampControllerCheckStamp200Response {
    /**
     * 
     * @type {CheckStampResponseDto}
     * @memberof StampControllerCheckStamp200Response
     */
    'data': CheckStampResponseDto;
    /**
     * 
     * @type {string}
     * @memberof StampControllerCheckStamp200Response
     */
    'status': StampControllerCheckStamp200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StampControllerCheckStamp200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof StampControllerCheckStamp200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof StampControllerCheckStamp200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof StampControllerCheckStamp200Response
     */
    'messageCode'?: string;
}

export const StampControllerCheckStamp200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type StampControllerCheckStamp200ResponseStatusEnum = typeof StampControllerCheckStamp200ResponseStatusEnum[keyof typeof StampControllerCheckStamp200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface StampEventDto
 */
export interface StampEventDto {
    /**
     * 
     * @type {number}
     * @memberof StampEventDto
     */
    'event_id': number;
    /**
     * 
     * @type {string}
     * @memberof StampEventDto
     */
    'event_date': string;
    /**
     * Hành động (GENERATION: 1, ACTIVATION: 2, RETAIL: 3, DESTRUCTION: 4)
     * @type {number}
     * @memberof StampEventDto
     */
    'biz_step': StampEventDtoBizStepEnum;
}

export const StampEventDtoBizStepEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type StampEventDtoBizStepEnum = typeof StampEventDtoBizStepEnum[keyof typeof StampEventDtoBizStepEnum];

/**
 * 
 * @export
 * @interface StampInfo
 */
export interface StampInfo {
    /**
     * ID tem do doanh nghiệp cấp phát, có tác dụng truy vết trong nội bộ doanh nghiệp
     * @type {number}
     * @memberof StampInfo
     */
    'biz_stamp_id': number;
    /**
     * ID tem do hệ thống cấp phát, có tác dụng truy vết toàn hệ thống
     * @type {number}
     * @memberof StampInfo
     */
    'stamp_id': number;
    /**
     * Mã tem
     * @type {string}
     * @memberof StampInfo
     */
    'stamp_code': string;
    /**
     * Số thứ tự tem trong doanh nghiệp
     * @type {number}
     * @memberof StampInfo
     */
    'biz_count_number': number;
    /**
     * Trạng thái tem (GENERATED: 1, ACTIVATED: 2, RETAILED: 3, DESTROYED: 4)
     * @type {number}
     * @memberof StampInfo
     */
    'state': StampInfoStateEnum;
    /**
     * Chế độ hiển thị tem (showImage: 1, showDate: 2)
     * @type {number}
     * @memberof StampInfo
     */
    'display_mode': StampInfoDisplayModeEnum;
    /**
     * Kích thước tem
     * @type {string}
     * @memberof StampInfo
     */
    'size': string;
    /**
     * 
     * @type {string}
     * @memberof StampInfo
     */
    'top_text': string;
    /**
     * 
     * @type {string}
     * @memberof StampInfo
     */
    'bottom_text': string;
    /**
     * 
     * @type {string}
     * @memberof StampInfo
     */
    'center_text': string;
    /**
     * 
     * @type {string}
     * @memberof StampInfo
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof StampInfo
     */
    'use_expired_date': number;
    /**
     * 
     * @type {number}
     * @memberof StampInfo
     */
    'use_activation_date': number;
}

export const StampInfoStateEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type StampInfoStateEnum = typeof StampInfoStateEnum[keyof typeof StampInfoStateEnum];
export const StampInfoDisplayModeEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type StampInfoDisplayModeEnum = typeof StampInfoDisplayModeEnum[keyof typeof StampInfoDisplayModeEnum];

/**
 * 
 * @export
 * @interface StampTemplateControllerCreate200Response
 */
export interface StampTemplateControllerCreate200Response {
    /**
     * 
     * @type {StampTemplateDetailDto}
     * @memberof StampTemplateControllerCreate200Response
     */
    'data': StampTemplateDetailDto;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateControllerCreate200Response
     */
    'status': StampTemplateControllerCreate200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateControllerCreate200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateControllerCreate200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof StampTemplateControllerCreate200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateControllerCreate200Response
     */
    'messageCode'?: string;
}

export const StampTemplateControllerCreate200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type StampTemplateControllerCreate200ResponseStatusEnum = typeof StampTemplateControllerCreate200ResponseStatusEnum[keyof typeof StampTemplateControllerCreate200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface StampTemplateControllerFindAllActive200Response
 */
export interface StampTemplateControllerFindAllActive200Response {
    /**
     * 
     * @type {Array<StampTemplateListItemDto>}
     * @memberof StampTemplateControllerFindAllActive200Response
     */
    'data': Array<StampTemplateListItemDto>;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateControllerFindAllActive200Response
     */
    'status': StampTemplateControllerFindAllActive200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateControllerFindAllActive200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateControllerFindAllActive200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof StampTemplateControllerFindAllActive200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateControllerFindAllActive200Response
     */
    'messageCode'?: string;
}

export const StampTemplateControllerFindAllActive200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type StampTemplateControllerFindAllActive200ResponseStatusEnum = typeof StampTemplateControllerFindAllActive200ResponseStatusEnum[keyof typeof StampTemplateControllerFindAllActive200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface StampTemplateDetailDto
 */
export interface StampTemplateDetailDto {
    /**
     * 
     * @type {number}
     * @memberof StampTemplateDetailDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateDetailDto
     */
    'name': string;
    /**
     * 15x15-6, 25x15-4, 35x22-3, 46x34-2, 15x15-4, 20x20-3, 30x30-2, 25x15-3, 35x22-2
     * @type {STAMPTEMPLATESIZE}
     * @memberof StampTemplateDetailDto
     */
    'size': STAMPTEMPLATESIZE;
    /**
     * active: 1, inactive: 2
     * @type {STAMPTEMPLATESTATUS}
     * @memberof StampTemplateDetailDto
     */
    'status': STAMPTEMPLATESTATUS;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateDetailDto
     */
    'topText': string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateDetailDto
     */
    'bottomText': string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateDetailDto
     */
    'centerText': string;
    /**
     * 1: use image, 2: use date
     * @type {STAMPTEMPLATEDISPLAYMODE}
     * @memberof StampTemplateDetailDto
     */
    'displayMode': STAMPTEMPLATEDISPLAYMODE;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateDetailDto
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof StampTemplateDetailDto
     */
    'useExpiredDate': number;
    /**
     * 
     * @type {number}
     * @memberof StampTemplateDetailDto
     */
    'useActivationDate': number;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateDetailDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateDetailDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateDetailDto
     */
    'created_by': string;
}


/**
 * 
 * @export
 * @interface StampTemplateListItemDto
 */
export interface StampTemplateListItemDto {
    /**
     * 
     * @type {number}
     * @memberof StampTemplateListItemDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateListItemDto
     */
    'name': string;
    /**
     * active: 1, inactive: 2
     * @type {STAMPTEMPLATESTATUS}
     * @memberof StampTemplateListItemDto
     */
    'status': STAMPTEMPLATESTATUS;
    /**
     * 15x15-6, 25x15-4, 35x22-3, 46x34-2, 15x15-4, 20x20-3, 30x30-2, 25x15-3, 35x22-2
     * @type {STAMPTEMPLATESIZE}
     * @memberof StampTemplateListItemDto
     */
    'size': STAMPTEMPLATESIZE;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateListItemDto
     */
    'topText': string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateListItemDto
     */
    'bottomText': string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateListItemDto
     */
    'centerText': string;
    /**
     * 1: use image, 2: use date
     * @type {STAMPTEMPLATEDISPLAYMODE}
     * @memberof StampTemplateListItemDto
     */
    'displayMode': STAMPTEMPLATEDISPLAYMODE;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateListItemDto
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof StampTemplateListItemDto
     */
    'useExpiredDate': number;
    /**
     * 
     * @type {number}
     * @memberof StampTemplateListItemDto
     */
    'useActivationDate': number;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateListItemDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateListItemDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof StampTemplateListItemDto
     */
    'created_by': string;
}


/**
 * 
 * @export
 * @interface TraceBizInfo
 */
export interface TraceBizInfo {
    /**
     * 
     * @type {number}
     * @memberof TraceBizInfo
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof TraceBizInfo
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof TraceBizInfo
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof TraceBizInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TraceBizInfo
     */
    'short_name': string;
    /**
     * 
     * @type {string}
     * @memberof TraceBizInfo
     */
    'full_name': string;
}
/**
 * 
 * @export
 * @interface TraceControllerTrace200Response
 */
export interface TraceControllerTrace200Response {
    /**
     * 
     * @type {TraceResponseDto}
     * @memberof TraceControllerTrace200Response
     */
    'data': TraceResponseDto;
    /**
     * 
     * @type {string}
     * @memberof TraceControllerTrace200Response
     */
    'status': TraceControllerTrace200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TraceControllerTrace200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TraceControllerTrace200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof TraceControllerTrace200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof TraceControllerTrace200Response
     */
    'messageCode'?: string;
}

export const TraceControllerTrace200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type TraceControllerTrace200ResponseStatusEnum = typeof TraceControllerTrace200ResponseStatusEnum[keyof typeof TraceControllerTrace200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface TraceResponseDto
 */
export interface TraceResponseDto {
    /**
     * 
     * @type {StampInfo}
     * @memberof TraceResponseDto
     */
    'stamp': StampInfo;
    /**
     * 
     * @type {ProductInfo}
     * @memberof TraceResponseDto
     */
    'product': ProductInfo;
    /**
     * 
     * @type {TraceBizInfo}
     * @memberof TraceResponseDto
     */
    'biz': TraceBizInfo;
    /**
     * 
     * @type {Array<StampEventDto>}
     * @memberof TraceResponseDto
     */
    'events': Array<StampEventDto>;
}
/**
 * 
 * @export
 * @interface UpdateBusinessDto
 */
export interface UpdateBusinessDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'name': string;
    /**
     * 1: Individual, 2: LegalEntity
     * @type {BUSINESSTYPE}
     * @memberof UpdateBusinessDto
     */
    'type': BUSINESSTYPE;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'shortName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'gcp'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'taxCode'?: string;
    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'businessRegistrationIssuedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'businessRegistrationIssuedPlace'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'provinceCode': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'districtCode': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'wardCode': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'addressDetail': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'website': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'youtube': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessDto
     */
    'logo': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBusinessDto
     */
    'slideImages': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBusinessDto
     */
    'introImages': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBusinessDto
     */
    'businessRegistrationScans': Array<string>;
}


/**
 * 
 * @export
 * @interface UpdateProductAttributeDto
 */
export interface UpdateProductAttributeDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateProductAttributeDto
     */
    'id': number;
    /**
     * 1: Product, 2: Activation, 3: Sale
     * @type {PRODUCTATTRIBUTETYPE}
     * @memberof UpdateProductAttributeDto
     */
    'type': PRODUCTATTRIBUTETYPE;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductAttributeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductAttributeDto
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductAttributeDto
     */
    'unit': string;
}


/**
 * 
 * @export
 * @interface UpdateProductDto
 */
export interface UpdateProductDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateProductDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProductDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'gtin': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'hsCode': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProductDto
     */
    'autoActivationSeconds': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateProductDto
     */
    'autoSaleSeconds': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateProductDto
     */
    'autoExpireSeconds': number;
    /**
     * 1: Hours, 2: Days, 3: Weeks, 4: Months
     * @type {PRODUCTEXPIREEXCHANGEUNIT}
     * @memberof UpdateProductDto
     */
    'autoExpireExchangeUnit': PRODUCTEXPIREEXCHANGEUNIT;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'youtubeLink': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProductDto
     */
    'slideImages': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProductDto
     */
    'introImages': Array<string>;
    /**
     * 
     * @type {Array<UpdateProductAttributeDto>}
     * @memberof UpdateProductDto
     */
    'attributes': Array<UpdateProductAttributeDto>;
}


/**
 * 
 * @export
 * @interface UpdateStampTemplateDto
 */
export interface UpdateStampTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateStampTemplateDto
     */
    'name': string;
    /**
     * 15x15-6, 25x15-4, 35x22-3, 46x34-2, 15x15-4, 20x20-3, 30x30-2, 25x15-3, 35x22-2
     * @type {STAMPTEMPLATESIZE}
     * @memberof UpdateStampTemplateDto
     */
    'size': STAMPTEMPLATESIZE;
    /**
     * 
     * @type {string}
     * @memberof UpdateStampTemplateDto
     */
    'topText': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStampTemplateDto
     */
    'bottomText': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStampTemplateDto
     */
    'centerText': string;
    /**
     * 1: use image, 2: use date
     * @type {STAMPTEMPLATEDISPLAYMODE}
     * @memberof UpdateStampTemplateDto
     */
    'displayMode': STAMPTEMPLATEDISPLAYMODE;
    /**
     * 
     * @type {string}
     * @memberof UpdateStampTemplateDto
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateStampTemplateDto
     */
    'useExpiredDate': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateStampTemplateDto
     */
    'useActivationDate': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateStampTemplateDto
     */
    'id': number;
}


/**
 * 
 * @export
 * @interface UploadControllerCloneBizResource200Response
 */
export interface UploadControllerCloneBizResource200Response {
    /**
     * 
     * @type {CloneFileResponseDto}
     * @memberof UploadControllerCloneBizResource200Response
     */
    'data': CloneFileResponseDto;
    /**
     * 
     * @type {string}
     * @memberof UploadControllerCloneBizResource200Response
     */
    'status': UploadControllerCloneBizResource200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UploadControllerCloneBizResource200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadControllerCloneBizResource200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof UploadControllerCloneBizResource200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof UploadControllerCloneBizResource200Response
     */
    'messageCode'?: string;
}

export const UploadControllerCloneBizResource200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type UploadControllerCloneBizResource200ResponseStatusEnum = typeof UploadControllerCloneBizResource200ResponseStatusEnum[keyof typeof UploadControllerCloneBizResource200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface UploadControllerUploadBizImages200Response
 */
export interface UploadControllerUploadBizImages200Response {
    /**
     * 
     * @type {Array<FileUploadResponseDto>}
     * @memberof UploadControllerUploadBizImages200Response
     */
    'data': Array<FileUploadResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof UploadControllerUploadBizImages200Response
     */
    'status': UploadControllerUploadBizImages200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UploadControllerUploadBizImages200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadControllerUploadBizImages200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof UploadControllerUploadBizImages200Response
     */
    'httpStatus': number;
    /**
     * 
     * @type {string}
     * @memberof UploadControllerUploadBizImages200Response
     */
    'messageCode'?: string;
}

export const UploadControllerUploadBizImages200ResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type UploadControllerUploadBizImages200ResponseStatusEnum = typeof UploadControllerUploadBizImages200ResponseStatusEnum[keyof typeof UploadControllerUploadBizImages200ResponseStatusEnum];


/**
 * ActivationApi - axios parameter creator
 * @export
 */
export const ActivationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateActivationDocDto} createActivationDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activationControllerCreate: async (createActivationDocDto: CreateActivationDocDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createActivationDocDto' is not null or undefined
            assertParamExists('activationControllerCreate', 'createActivationDocDto', createActivationDocDto)
            const localVarPath = `/api/stamp/activation/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createActivationDocDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {number} [toDate] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activationControllerFindAll: async (page?: number, perpage?: number, fromDate?: string, toDate?: number, productId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stamp/activation/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activationControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activationControllerFindOne', 'id', id)
            const localVarPath = `/api/stamp/activation/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivationApi - functional programming interface
 * @export
 */
export const ActivationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateActivationDocDto} createActivationDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activationControllerCreate(createActivationDocDto: CreateActivationDocDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivationControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activationControllerCreate(createActivationDocDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivationApi.activationControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {number} [toDate] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activationControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: number, productId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizUserControllerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activationControllerFindAll(page, perpage, fromDate, toDate, productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivationApi.activationControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activationControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivationControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activationControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivationApi.activationControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivationApi - factory interface
 * @export
 */
export const ActivationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivationApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateActivationDocDto} createActivationDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activationControllerCreate(createActivationDocDto: CreateActivationDocDto, options?: RawAxiosRequestConfig): AxiosPromise<ActivationControllerCreate200Response> {
            return localVarFp.activationControllerCreate(createActivationDocDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {number} [toDate] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activationControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: number, productId?: number, options?: RawAxiosRequestConfig): AxiosPromise<BizUserControllerList200Response> {
            return localVarFp.activationControllerFindAll(page, perpage, fromDate, toDate, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activationControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ActivationControllerCreate200Response> {
            return localVarFp.activationControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivationApi - object-oriented interface
 * @export
 * @class ActivationApi
 * @extends {BaseAPI}
 */
export class ActivationApi extends BaseAPI {
    /**
     * 
     * @param {CreateActivationDocDto} createActivationDocDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivationApi
     */
    public activationControllerCreate(createActivationDocDto: CreateActivationDocDto, options?: RawAxiosRequestConfig) {
        return ActivationApiFp(this.configuration).activationControllerCreate(createActivationDocDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Default value is 1
     * @param {number} [perpage] Default value is 20
     * @param {string} [fromDate] 
     * @param {number} [toDate] 
     * @param {number} [productId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivationApi
     */
    public activationControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: number, productId?: number, options?: RawAxiosRequestConfig) {
        return ActivationApiFp(this.configuration).activationControllerFindAll(page, perpage, fromDate, toDate, productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivationApi
     */
    public activationControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ActivationApiFp(this.configuration).activationControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppControllerGetCurrentUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.appControllerGetCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<AppControllerGetCurrentUser200Response> {
            return localVarFp.appControllerGetCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppApi
     */
    public appControllerGetCurrentUser(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).appControllerGetCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangeBusinessDto} changeBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangeBusiness: async (changeBusinessDto: ChangeBusinessDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeBusinessDto' is not null or undefined
            assertParamExists('authControllerChangeBusiness', 'changeBusinessDto', changeBusinessDto)
            const localVarPath = `/api/auth/change-business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeBusinessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetZaloAuthUrl: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/zalo-auth-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bizId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLeaveBusiness: async (bizId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bizId' is not null or undefined
            assertParamExists('authControllerLeaveBusiness', 'bizId', bizId)
            const localVarPath = `/api/auth/leave-business/{bizId}`
                .replace(`{${"bizId"}}`, encodeURIComponent(String(bizId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginWithPasswordDto} loginWithPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithPassword: async (loginWithPasswordDto: LoginWithPasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWithPasswordDto' is not null or undefined
            assertParamExists('authControllerLoginWithPassword', 'loginWithPasswordDto', loginWithPasswordDto)
            const localVarPath = `/api/auth/login-with-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginWithPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginWithZaloDto} loginWithZaloDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithZalo: async (loginWithZaloDto: LoginWithZaloDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWithZaloDto' is not null or undefined
            assertParamExists('authControllerLoginWithZalo', 'loginWithZaloDto', loginWithZaloDto)
            const localVarPath = `/api/auth/login-with-zalo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginWithZaloDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeBusinessDto} changeBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSetDefaultBusiness: async (changeBusinessDto: ChangeBusinessDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeBusinessDto' is not null or undefined
            assertParamExists('authControllerSetDefaultBusiness', 'changeBusinessDto', changeBusinessDto)
            const localVarPath = `/api/auth/set-default-business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeBusinessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpWithPasswordDto} signUpWithPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithPassword: async (signUpWithPasswordDto: SignUpWithPasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpWithPasswordDto' is not null or undefined
            assertParamExists('authControllerSignUpWithPassword', 'signUpWithPasswordDto', signUpWithPasswordDto)
            const localVarPath = `/api/auth/sign-up-with-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpWithPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ChangeBusinessDto} changeBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerChangeBusiness(changeBusinessDto: ChangeBusinessDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLoginWithPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangeBusiness(changeBusinessDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerChangeBusiness']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetZaloAuthUrl(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerGetZaloAuthUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetZaloAuthUrl(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetZaloAuthUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bizId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLeaveBusiness(bizId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLeaveBusiness(bizId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLeaveBusiness']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginWithPasswordDto} loginWithPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithPassword(loginWithPasswordDto: LoginWithPasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLoginWithPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithPassword(loginWithPasswordDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLoginWithPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginWithZaloDto} loginWithZaloDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginWithZalo(loginWithZaloDto: LoginWithZaloDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLoginWithPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginWithZalo(loginWithZaloDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLoginWithZalo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLoginWithPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ChangeBusinessDto} changeBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSetDefaultBusiness(changeBusinessDto: ChangeBusinessDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLoginWithPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSetDefaultBusiness(changeBusinessDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSetDefaultBusiness']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpWithPasswordDto} signUpWithPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignUpWithPassword(signUpWithPasswordDto: SignUpWithPasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLoginWithPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignUpWithPassword(signUpWithPasswordDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignUpWithPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {ChangeBusinessDto} changeBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangeBusiness(changeBusinessDto: ChangeBusinessDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLoginWithPassword200Response> {
            return localVarFp.authControllerChangeBusiness(changeBusinessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetZaloAuthUrl(options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerGetZaloAuthUrl200Response> {
            return localVarFp.authControllerGetZaloAuthUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bizId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLeaveBusiness(bizId: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.authControllerLeaveBusiness(bizId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginWithPasswordDto} loginWithPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithPassword(loginWithPasswordDto: LoginWithPasswordDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLoginWithPassword200Response> {
            return localVarFp.authControllerLoginWithPassword(loginWithPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginWithZaloDto} loginWithZaloDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginWithZalo(loginWithZaloDto: LoginWithZaloDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLoginWithPassword200Response> {
            return localVarFp.authControllerLoginWithZalo(loginWithZaloDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens(options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLoginWithPassword200Response> {
            return localVarFp.authControllerRefreshTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangeBusinessDto} changeBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSetDefaultBusiness(changeBusinessDto: ChangeBusinessDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLoginWithPassword200Response> {
            return localVarFp.authControllerSetDefaultBusiness(changeBusinessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpWithPasswordDto} signUpWithPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithPassword(signUpWithPasswordDto: SignUpWithPasswordDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLoginWithPassword200Response> {
            return localVarFp.authControllerSignUpWithPassword(signUpWithPasswordDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {ChangeBusinessDto} changeBusinessDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerChangeBusiness(changeBusinessDto: ChangeBusinessDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerChangeBusiness(changeBusinessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetZaloAuthUrl(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetZaloAuthUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bizId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLeaveBusiness(bizId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLeaveBusiness(bizId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginWithPasswordDto} loginWithPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLoginWithPassword(loginWithPasswordDto: LoginWithPasswordDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLoginWithPassword(loginWithPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginWithZaloDto} loginWithZaloDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLoginWithZalo(loginWithZaloDto: LoginWithZaloDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLoginWithZalo(loginWithZaloDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangeBusinessDto} changeBusinessDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSetDefaultBusiness(changeBusinessDto: ChangeBusinessDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSetDefaultBusiness(changeBusinessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpWithPasswordDto} signUpWithPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignUpWithPassword(signUpWithPasswordDto: SignUpWithPasswordDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignUpWithPassword(signUpWithPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BizUserApi - axios parameter creator
 * @export
 */
export const BizUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangeRoleDto} changeRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerChangeRole: async (changeRoleDto: ChangeRoleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeRoleDto' is not null or undefined
            assertParamExists('bizUserControllerChangeRole', 'changeRoleDto', changeRoleDto)
            const localVarPath = `/api/biz-user/change-role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bizUserControllerFindOne', 'id', id)
            const localVarPath = `/api/biz-user/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [q] Search by full name, email, phone
         * @param {number} [status] Filter by status
         * @param {number} [role] Filter by role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerList: async (page?: number, perpage?: number, q?: string, status?: number, role?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/biz-user/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerLock: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bizUserControllerLock', 'id', id)
            const localVarPath = `/api/biz-user/lock/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerUnlock: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bizUserControllerUnlock', 'id', id)
            const localVarPath = `/api/biz-user/unlock/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BizUserApi - functional programming interface
 * @export
 */
export const BizUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BizUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ChangeRoleDto} changeRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bizUserControllerChangeRole(changeRoleDto: ChangeRoleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bizUserControllerChangeRole(changeRoleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BizUserApi.bizUserControllerChangeRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bizUserControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bizUserControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BizUserApi.bizUserControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [q] Search by full name, email, phone
         * @param {number} [status] Filter by status
         * @param {number} [role] Filter by role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bizUserControllerList(page?: number, perpage?: number, q?: string, status?: number, role?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizUserControllerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bizUserControllerList(page, perpage, q, status, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BizUserApi.bizUserControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bizUserControllerLock(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bizUserControllerLock(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BizUserApi.bizUserControllerLock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bizUserControllerUnlock(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bizUserControllerUnlock(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BizUserApi.bizUserControllerUnlock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BizUserApi - factory interface
 * @export
 */
export const BizUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BizUserApiFp(configuration)
    return {
        /**
         * 
         * @param {ChangeRoleDto} changeRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerChangeRole(changeRoleDto: ChangeRoleDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bizUserControllerChangeRole(changeRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bizUserControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [q] Search by full name, email, phone
         * @param {number} [status] Filter by status
         * @param {number} [role] Filter by role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerList(page?: number, perpage?: number, q?: string, status?: number, role?: number, options?: RawAxiosRequestConfig): AxiosPromise<BizUserControllerList200Response> {
            return localVarFp.bizUserControllerList(page, perpage, q, status, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerLock(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bizUserControllerLock(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bizUserControllerUnlock(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bizUserControllerUnlock(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BizUserApi - object-oriented interface
 * @export
 * @class BizUserApi
 * @extends {BaseAPI}
 */
export class BizUserApi extends BaseAPI {
    /**
     * 
     * @param {ChangeRoleDto} changeRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BizUserApi
     */
    public bizUserControllerChangeRole(changeRoleDto: ChangeRoleDto, options?: RawAxiosRequestConfig) {
        return BizUserApiFp(this.configuration).bizUserControllerChangeRole(changeRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BizUserApi
     */
    public bizUserControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return BizUserApiFp(this.configuration).bizUserControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Default value is 1
     * @param {number} [perpage] Default value is 20
     * @param {string} [q] Search by full name, email, phone
     * @param {number} [status] Filter by status
     * @param {number} [role] Filter by role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BizUserApi
     */
    public bizUserControllerList(page?: number, perpage?: number, q?: string, status?: number, role?: number, options?: RawAxiosRequestConfig) {
        return BizUserApiFp(this.configuration).bizUserControllerList(page, perpage, q, status, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BizUserApi
     */
    public bizUserControllerLock(id: string, options?: RawAxiosRequestConfig) {
        return BizUserApiFp(this.configuration).bizUserControllerLock(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BizUserApi
     */
    public bizUserControllerUnlock(id: string, options?: RawAxiosRequestConfig) {
        return BizUserApiFp(this.configuration).bizUserControllerUnlock(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BusinessApi - axios parameter creator
 * @export
 */
export const BusinessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {BUSINESSTYPE} type 1: Individual, 2: LegalEntity
         * @param {string} phone 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {string} [email] 
         * @param {string} [gcp] 
         * @param {string} [taxCode] 
         * @param {string} [businessRegistrationIssuedDate] 
         * @param {string} [businessRegistrationIssuedPlace] 
         * @param {Array<File>} [logoUpload] Upload logo, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {Array<File>} [businessRegistrationScanUpload] Upload business registration scan, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessControllerCreateBusiness: async (name: string, type: BUSINESSTYPE, phone: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, email?: string, gcp?: string, taxCode?: string, businessRegistrationIssuedDate?: string, businessRegistrationIssuedPlace?: string, logoUpload?: Array<File>, businessRegistrationScanUpload?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('businessControllerCreateBusiness', 'name', name)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('businessControllerCreateBusiness', 'type', type)
            // verify required parameter 'phone' is not null or undefined
            assertParamExists('businessControllerCreateBusiness', 'phone', phone)
            // verify required parameter 'provinceCode' is not null or undefined
            assertParamExists('businessControllerCreateBusiness', 'provinceCode', provinceCode)
            // verify required parameter 'districtCode' is not null or undefined
            assertParamExists('businessControllerCreateBusiness', 'districtCode', districtCode)
            // verify required parameter 'wardCode' is not null or undefined
            assertParamExists('businessControllerCreateBusiness', 'wardCode', wardCode)
            // verify required parameter 'addressDetail' is not null or undefined
            assertParamExists('businessControllerCreateBusiness', 'addressDetail', addressDetail)
            const localVarPath = `/api/business/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
            if (phone !== undefined) { 
                localVarFormParams.append('phone', phone as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (gcp !== undefined) { 
                localVarFormParams.append('gcp', gcp as any);
            }
    
            if (taxCode !== undefined) { 
                localVarFormParams.append('taxCode', taxCode as any);
            }
    
            if (businessRegistrationIssuedDate !== undefined) { 
                localVarFormParams.append('businessRegistrationIssuedDate', businessRegistrationIssuedDate as any);
            }
    
            if (businessRegistrationIssuedPlace !== undefined) { 
                localVarFormParams.append('businessRegistrationIssuedPlace', businessRegistrationIssuedPlace as any);
            }
    
            if (provinceCode !== undefined) { 
                localVarFormParams.append('provinceCode', provinceCode as any);
            }
    
            if (districtCode !== undefined) { 
                localVarFormParams.append('districtCode', districtCode as any);
            }
    
            if (wardCode !== undefined) { 
                localVarFormParams.append('wardCode', wardCode as any);
            }
    
            if (addressDetail !== undefined) { 
                localVarFormParams.append('addressDetail', addressDetail as any);
            }
                if (logoUpload) {
                logoUpload.forEach((element) => {
                    localVarFormParams.append('logoUpload', element as any);
                })
            }

                if (businessRegistrationScanUpload) {
                businessRegistrationScanUpload.forEach((element) => {
                    localVarFormParams.append('businessRegistrationScanUpload', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessControllerGetBusinessList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessControllerGetCurrentBusiness: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/business/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateBusinessDto} updateBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessControllerUpdateBusiness: async (updateBusinessDto: UpdateBusinessDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateBusinessDto' is not null or undefined
            assertParamExists('businessControllerUpdateBusiness', 'updateBusinessDto', updateBusinessDto)
            const localVarPath = `/api/business/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBusinessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessApi - functional programming interface
 * @export
 */
export const BusinessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} name 
         * @param {BUSINESSTYPE} type 1: Individual, 2: LegalEntity
         * @param {string} phone 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {string} [email] 
         * @param {string} [gcp] 
         * @param {string} [taxCode] 
         * @param {string} [businessRegistrationIssuedDate] 
         * @param {string} [businessRegistrationIssuedPlace] 
         * @param {Array<File>} [logoUpload] Upload logo, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {Array<File>} [businessRegistrationScanUpload] Upload business registration scan, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessControllerCreateBusiness(name: string, type: BUSINESSTYPE, phone: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, email?: string, gcp?: string, taxCode?: string, businessRegistrationIssuedDate?: string, businessRegistrationIssuedPlace?: string, logoUpload?: Array<File>, businessRegistrationScanUpload?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessControllerCreateBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessControllerCreateBusiness(name, type, phone, provinceCode, districtCode, wardCode, addressDetail, email, gcp, taxCode, businessRegistrationIssuedDate, businessRegistrationIssuedPlace, logoUpload, businessRegistrationScanUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessControllerCreateBusiness']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessControllerGetBusinessList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessControllerGetBusinessList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessControllerGetBusinessList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessControllerGetBusinessList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessControllerGetCurrentBusiness(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessControllerGetCurrentBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessControllerGetCurrentBusiness(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessControllerGetCurrentBusiness']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateBusinessDto} updateBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessControllerUpdateBusiness(updateBusinessDto: UpdateBusinessDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessControllerUpdateBusiness(updateBusinessDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessControllerUpdateBusiness']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BusinessApi - factory interface
 * @export
 */
export const BusinessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessApiFp(configuration)
    return {
        /**
         * 
         * @param {string} name 
         * @param {BUSINESSTYPE} type 1: Individual, 2: LegalEntity
         * @param {string} phone 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {string} [email] 
         * @param {string} [gcp] 
         * @param {string} [taxCode] 
         * @param {string} [businessRegistrationIssuedDate] 
         * @param {string} [businessRegistrationIssuedPlace] 
         * @param {Array<File>} [logoUpload] Upload logo, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {Array<File>} [businessRegistrationScanUpload] Upload business registration scan, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessControllerCreateBusiness(name: string, type: BUSINESSTYPE, phone: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, email?: string, gcp?: string, taxCode?: string, businessRegistrationIssuedDate?: string, businessRegistrationIssuedPlace?: string, logoUpload?: Array<File>, businessRegistrationScanUpload?: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<BusinessControllerCreateBusiness200Response> {
            return localVarFp.businessControllerCreateBusiness(name, type, phone, provinceCode, districtCode, wardCode, addressDetail, email, gcp, taxCode, businessRegistrationIssuedDate, businessRegistrationIssuedPlace, logoUpload, businessRegistrationScanUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessControllerGetBusinessList(options?: RawAxiosRequestConfig): AxiosPromise<BusinessControllerGetBusinessList200Response> {
            return localVarFp.businessControllerGetBusinessList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessControllerGetCurrentBusiness(options?: RawAxiosRequestConfig): AxiosPromise<BusinessControllerGetCurrentBusiness200Response> {
            return localVarFp.businessControllerGetCurrentBusiness(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateBusinessDto} updateBusinessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessControllerUpdateBusiness(updateBusinessDto: UpdateBusinessDto, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.businessControllerUpdateBusiness(updateBusinessDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BusinessApi - object-oriented interface
 * @export
 * @class BusinessApi
 * @extends {BaseAPI}
 */
export class BusinessApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {BUSINESSTYPE} type 1: Individual, 2: LegalEntity
     * @param {string} phone 
     * @param {string} provinceCode 
     * @param {string} districtCode 
     * @param {string} wardCode 
     * @param {string} addressDetail 
     * @param {string} [email] 
     * @param {string} [gcp] 
     * @param {string} [taxCode] 
     * @param {string} [businessRegistrationIssuedDate] 
     * @param {string} [businessRegistrationIssuedPlace] 
     * @param {Array<File>} [logoUpload] Upload logo, allow file type: jpg, jpeg, png and and size &lt; 2MB
     * @param {Array<File>} [businessRegistrationScanUpload] Upload business registration scan, allow file type: jpg, jpeg, png and and size &lt; 2MB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessControllerCreateBusiness(name: string, type: BUSINESSTYPE, phone: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, email?: string, gcp?: string, taxCode?: string, businessRegistrationIssuedDate?: string, businessRegistrationIssuedPlace?: string, logoUpload?: Array<File>, businessRegistrationScanUpload?: Array<File>, options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessControllerCreateBusiness(name, type, phone, provinceCode, districtCode, wardCode, addressDetail, email, gcp, taxCode, businessRegistrationIssuedDate, businessRegistrationIssuedPlace, logoUpload, businessRegistrationScanUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessControllerGetBusinessList(options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessControllerGetBusinessList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessControllerGetCurrentBusiness(options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessControllerGetCurrentBusiness(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateBusinessDto} updateBusinessDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessControllerUpdateBusiness(updateBusinessDto: UpdateBusinessDto, options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessControllerUpdateBusiness(updateBusinessDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DestructionApi - axios parameter creator
 * @export
 */
export const DestructionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDestructionDto} createDestructionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destructionControllerCreate: async (createDestructionDto: CreateDestructionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDestructionDto' is not null or undefined
            assertParamExists('destructionControllerCreate', 'createDestructionDto', createDestructionDto)
            const localVarPath = `/api/destruction/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDestructionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {string} [stampCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destructionControllerFindAll: async (page?: number, perpage?: number, fromDate?: string, toDate?: string, stampCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/destruction/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (stampCode !== undefined) {
                localVarQueryParameter['stampCode'] = stampCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destructionControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destructionControllerFindOne', 'id', id)
            const localVarPath = `/api/destruction/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DestructionApi - functional programming interface
 * @export
 */
export const DestructionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DestructionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateDestructionDto} createDestructionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destructionControllerCreate(createDestructionDto: CreateDestructionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestructionControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destructionControllerCreate(createDestructionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DestructionApi.destructionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {string} [stampCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destructionControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: string, stampCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizUserControllerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destructionControllerFindAll(page, perpage, fromDate, toDate, stampCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DestructionApi.destructionControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destructionControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestructionControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destructionControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DestructionApi.destructionControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DestructionApi - factory interface
 * @export
 */
export const DestructionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DestructionApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateDestructionDto} createDestructionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destructionControllerCreate(createDestructionDto: CreateDestructionDto, options?: RawAxiosRequestConfig): AxiosPromise<DestructionControllerCreate200Response> {
            return localVarFp.destructionControllerCreate(createDestructionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {string} [stampCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destructionControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: string, stampCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<BizUserControllerList200Response> {
            return localVarFp.destructionControllerFindAll(page, perpage, fromDate, toDate, stampCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destructionControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DestructionControllerCreate200Response> {
            return localVarFp.destructionControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DestructionApi - object-oriented interface
 * @export
 * @class DestructionApi
 * @extends {BaseAPI}
 */
export class DestructionApi extends BaseAPI {
    /**
     * 
     * @param {CreateDestructionDto} createDestructionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestructionApi
     */
    public destructionControllerCreate(createDestructionDto: CreateDestructionDto, options?: RawAxiosRequestConfig) {
        return DestructionApiFp(this.configuration).destructionControllerCreate(createDestructionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Default value is 1
     * @param {number} [perpage] Default value is 20
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {string} [stampCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestructionApi
     */
    public destructionControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: string, stampCode?: string, options?: RawAxiosRequestConfig) {
        return DestructionApiFp(this.configuration).destructionControllerFindAll(page, perpage, fromDate, toDate, stampCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DestructionApi
     */
    public destructionControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return DestructionApiFp(this.configuration).destructionControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenerationApi - axios parameter creator
 * @export
 */
export const GenerationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerDetailGenerationDoc: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('generationControllerDetailGenerationDoc', 'id', id)
            const localVarPath = `/api/stamp/generation/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePreactiveDocDto} createPreactiveDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerGeneratePreactiveStamp: async (createPreactiveDocDto: CreatePreactiveDocDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPreactiveDocDto' is not null or undefined
            assertParamExists('generationControllerGeneratePreactiveStamp', 'createPreactiveDocDto', createPreactiveDocDto)
            const localVarPath = `/api/stamp/generation/add-preactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPreactiveDocDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateGenerationDocDto} createGenerationDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerGenerateStamp: async (createGenerationDocDto: CreateGenerationDocDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGenerationDocDto' is not null or undefined
            assertParamExists('generationControllerGenerateStamp', 'createGenerationDocDto', createGenerationDocDto)
            const localVarPath = `/api/stamp/generation/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGenerationDocDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerGetPrintUrl: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('generationControllerGetPrintUrl', 'id', id)
            const localVarPath = `/api/stamp/generation/print-url/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {number} [toDate] 
         * @param {number} [templateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerListGenerationDoc: async (page?: number, perpage?: number, fromDate?: string, toDate?: number, templateId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stamp/generation/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenerationApi - functional programming interface
 * @export
 */
export const GenerationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenerationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generationControllerDetailGenerationDoc(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerationControllerGenerateStamp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generationControllerDetailGenerationDoc(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenerationApi.generationControllerDetailGenerationDoc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreatePreactiveDocDto} createPreactiveDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generationControllerGeneratePreactiveStamp(createPreactiveDocDto: CreatePreactiveDocDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerationControllerGenerateStamp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generationControllerGeneratePreactiveStamp(createPreactiveDocDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenerationApi.generationControllerGeneratePreactiveStamp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateGenerationDocDto} createGenerationDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generationControllerGenerateStamp(createGenerationDocDto: CreateGenerationDocDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerationControllerGenerateStamp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generationControllerGenerateStamp(createGenerationDocDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenerationApi.generationControllerGenerateStamp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generationControllerGetPrintUrl(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerationControllerGetPrintUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generationControllerGetPrintUrl(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenerationApi.generationControllerGetPrintUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {number} [toDate] 
         * @param {number} [templateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generationControllerListGenerationDoc(page?: number, perpage?: number, fromDate?: string, toDate?: number, templateId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizUserControllerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generationControllerListGenerationDoc(page, perpage, fromDate, toDate, templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenerationApi.generationControllerListGenerationDoc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenerationApi - factory interface
 * @export
 */
export const GenerationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenerationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerDetailGenerationDoc(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GenerationControllerGenerateStamp200Response> {
            return localVarFp.generationControllerDetailGenerationDoc(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePreactiveDocDto} createPreactiveDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerGeneratePreactiveStamp(createPreactiveDocDto: CreatePreactiveDocDto, options?: RawAxiosRequestConfig): AxiosPromise<GenerationControllerGenerateStamp200Response> {
            return localVarFp.generationControllerGeneratePreactiveStamp(createPreactiveDocDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateGenerationDocDto} createGenerationDocDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerGenerateStamp(createGenerationDocDto: CreateGenerationDocDto, options?: RawAxiosRequestConfig): AxiosPromise<GenerationControllerGenerateStamp200Response> {
            return localVarFp.generationControllerGenerateStamp(createGenerationDocDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerGetPrintUrl(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GenerationControllerGetPrintUrl200Response> {
            return localVarFp.generationControllerGetPrintUrl(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {number} [toDate] 
         * @param {number} [templateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generationControllerListGenerationDoc(page?: number, perpage?: number, fromDate?: string, toDate?: number, templateId?: number, options?: RawAxiosRequestConfig): AxiosPromise<BizUserControllerList200Response> {
            return localVarFp.generationControllerListGenerationDoc(page, perpage, fromDate, toDate, templateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenerationApi - object-oriented interface
 * @export
 * @class GenerationApi
 * @extends {BaseAPI}
 */
export class GenerationApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenerationApi
     */
    public generationControllerDetailGenerationDoc(id: string, options?: RawAxiosRequestConfig) {
        return GenerationApiFp(this.configuration).generationControllerDetailGenerationDoc(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreatePreactiveDocDto} createPreactiveDocDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenerationApi
     */
    public generationControllerGeneratePreactiveStamp(createPreactiveDocDto: CreatePreactiveDocDto, options?: RawAxiosRequestConfig) {
        return GenerationApiFp(this.configuration).generationControllerGeneratePreactiveStamp(createPreactiveDocDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateGenerationDocDto} createGenerationDocDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenerationApi
     */
    public generationControllerGenerateStamp(createGenerationDocDto: CreateGenerationDocDto, options?: RawAxiosRequestConfig) {
        return GenerationApiFp(this.configuration).generationControllerGenerateStamp(createGenerationDocDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenerationApi
     */
    public generationControllerGetPrintUrl(id: string, options?: RawAxiosRequestConfig) {
        return GenerationApiFp(this.configuration).generationControllerGetPrintUrl(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Default value is 1
     * @param {number} [perpage] Default value is 20
     * @param {string} [fromDate] 
     * @param {number} [toDate] 
     * @param {number} [templateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenerationApi
     */
    public generationControllerListGenerationDoc(page?: number, perpage?: number, fromDate?: string, toDate?: number, templateId?: number, options?: RawAxiosRequestConfig) {
        return GenerationApiFp(this.configuration).generationControllerListGenerationDoc(page, perpage, fromDate, toDate, templateId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvitationApi - axios parameter creator
 * @export
 */
export const InvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationControllerCancel: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invitationControllerCancel', 'id', id)
            const localVarPath = `/api/invitation/cancel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateInvitationDto} createInvitationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationControllerCreate: async (createInvitationDto: CreateInvitationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInvitationDto' is not null or undefined
            assertParamExists('invitationControllerCreate', 'createInvitationDto', createInvitationDto)
            const localVarPath = `/api/invitation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInvitationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invitationControllerFindOne', 'id', id)
            const localVarPath = `/api/invitation/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [phone] 
         * @param {number} [status] pending: 1, accepted: 2, rejected: 3, cancelled: 4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationControllerSearch: async (page?: number, perpage?: number, phone?: string, status?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invitation/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 * @export
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationControllerCancel(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationControllerCancel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.invitationControllerCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateInvitationDto} createInvitationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationControllerCreate(createInvitationDto: CreateInvitationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvitationControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationControllerCreate(createInvitationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.invitationControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvitationControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.invitationControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [phone] 
         * @param {number} [status] pending: 1, accepted: 2, rejected: 3, cancelled: 4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationControllerSearch(page?: number, perpage?: number, phone?: string, status?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizUserControllerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationControllerSearch(page, perpage, phone, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitationApi.invitationControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvitationApi - factory interface
 * @export
 */
export const InvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationControllerCancel(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.invitationControllerCancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateInvitationDto} createInvitationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationControllerCreate(createInvitationDto: CreateInvitationDto, options?: RawAxiosRequestConfig): AxiosPromise<InvitationControllerCreate200Response> {
            return localVarFp.invitationControllerCreate(createInvitationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<InvitationControllerFindOne200Response> {
            return localVarFp.invitationControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [phone] 
         * @param {number} [status] pending: 1, accepted: 2, rejected: 3, cancelled: 4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationControllerSearch(page?: number, perpage?: number, phone?: string, status?: number, options?: RawAxiosRequestConfig): AxiosPromise<BizUserControllerList200Response> {
            return localVarFp.invitationControllerSearch(page, perpage, phone, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
export class InvitationApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public invitationControllerCancel(id: string, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).invitationControllerCancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateInvitationDto} createInvitationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public invitationControllerCreate(createInvitationDto: CreateInvitationDto, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).invitationControllerCreate(createInvitationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public invitationControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).invitationControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Default value is 1
     * @param {number} [perpage] Default value is 20
     * @param {string} [phone] 
     * @param {number} [status] pending: 1, accepted: 2, rejected: 3, cancelled: 4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public invitationControllerSearch(page?: number, perpage?: number, phone?: string, status?: number, options?: RawAxiosRequestConfig) {
        return InvitationApiFp(this.configuration).invitationControllerSearch(page, perpage, phone, status, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} provinceCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationControllerGetDistricts: async (provinceCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provinceCode' is not null or undefined
            assertParamExists('locationControllerGetDistricts', 'provinceCode', provinceCode)
            const localVarPath = `/api/location/districts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (provinceCode !== undefined) {
                localVarQueryParameter['provinceCode'] = provinceCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationControllerGetProvinces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/location/provinces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} districtCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationControllerGetWards: async (districtCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'districtCode' is not null or undefined
            assertParamExists('locationControllerGetWards', 'districtCode', districtCode)
            const localVarPath = `/api/location/wards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (districtCode !== undefined) {
                localVarQueryParameter['districtCode'] = districtCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} provinceCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationControllerGetDistricts(provinceCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationControllerGetProvinces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationControllerGetDistricts(provinceCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationControllerGetDistricts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationControllerGetProvinces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationControllerGetProvinces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationControllerGetProvinces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationControllerGetProvinces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} districtCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationControllerGetWards(districtCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationControllerGetProvinces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationControllerGetWards(districtCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.locationControllerGetWards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} provinceCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationControllerGetDistricts(provinceCode: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationControllerGetProvinces200Response> {
            return localVarFp.locationControllerGetDistricts(provinceCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationControllerGetProvinces(options?: RawAxiosRequestConfig): AxiosPromise<LocationControllerGetProvinces200Response> {
            return localVarFp.locationControllerGetProvinces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} districtCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationControllerGetWards(districtCode: string, options?: RawAxiosRequestConfig): AxiosPromise<LocationControllerGetProvinces200Response> {
            return localVarFp.locationControllerGetWards(districtCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * 
     * @param {string} provinceCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationControllerGetDistricts(provinceCode: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationControllerGetDistricts(provinceCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationControllerGetProvinces(options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationControllerGetProvinces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} districtCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public locationControllerGetWards(districtCode: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).locationControllerGetWards(districtCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MyInvitationApi - axios parameter creator
 * @export
 */
export const MyInvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInvitationControllerAcceptInvitation: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('myInvitationControllerAcceptInvitation', 'code', code)
            const localVarPath = `/api/my-invitation/accept/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInvitationControllerFindOne: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('myInvitationControllerFindOne', 'code', code)
            const localVarPath = `/api/my-invitation/detail/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInvitationControllerRejectInvitation: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('myInvitationControllerRejectInvitation', 'code', code)
            const localVarPath = `/api/my-invitation/reject/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInvitationControllerSearch: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/my-invitation/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyInvitationApi - functional programming interface
 * @export
 */
export const MyInvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyInvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myInvitationControllerAcceptInvitation(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myInvitationControllerAcceptInvitation(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyInvitationApi.myInvitationControllerAcceptInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myInvitationControllerFindOne(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MyInvitationControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myInvitationControllerFindOne(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyInvitationApi.myInvitationControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myInvitationControllerRejectInvitation(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myInvitationControllerRejectInvitation(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyInvitationApi.myInvitationControllerRejectInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myInvitationControllerSearch(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MyInvitationControllerSearch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myInvitationControllerSearch(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyInvitationApi.myInvitationControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MyInvitationApi - factory interface
 * @export
 */
export const MyInvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyInvitationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInvitationControllerAcceptInvitation(code: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.myInvitationControllerAcceptInvitation(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInvitationControllerFindOne(code: string, options?: RawAxiosRequestConfig): AxiosPromise<MyInvitationControllerFindOne200Response> {
            return localVarFp.myInvitationControllerFindOne(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInvitationControllerRejectInvitation(code: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.myInvitationControllerRejectInvitation(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInvitationControllerSearch(options?: RawAxiosRequestConfig): AxiosPromise<MyInvitationControllerSearch200Response> {
            return localVarFp.myInvitationControllerSearch(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MyInvitationApi - object-oriented interface
 * @export
 * @class MyInvitationApi
 * @extends {BaseAPI}
 */
export class MyInvitationApi extends BaseAPI {
    /**
     * 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyInvitationApi
     */
    public myInvitationControllerAcceptInvitation(code: string, options?: RawAxiosRequestConfig) {
        return MyInvitationApiFp(this.configuration).myInvitationControllerAcceptInvitation(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyInvitationApi
     */
    public myInvitationControllerFindOne(code: string, options?: RawAxiosRequestConfig) {
        return MyInvitationApiFp(this.configuration).myInvitationControllerFindOne(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyInvitationApi
     */
    public myInvitationControllerRejectInvitation(code: string, options?: RawAxiosRequestConfig) {
        return MyInvitationApiFp(this.configuration).myInvitationControllerRejectInvitation(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyInvitationApi
     */
    public myInvitationControllerSearch(options?: RawAxiosRequestConfig) {
        return MyInvitationApiFp(this.configuration).myInvitationControllerSearch(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerCreate: async (createProductDto: CreateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductDto' is not null or undefined
            assertParamExists('productControllerCreate', 'createProductDto', createProductDto)
            const localVarPath = `/api/product/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [name] Product name
         * @param {ProductControllerFindAllStatusEnum} [status] Product status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAll: async (page?: number, perpage?: number, name?: string, status?: ProductControllerFindAllStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/product/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAllActive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/product/list-active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAttributes: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerFindAttributes', 'id', id)
            const localVarPath = `/api/product/attributes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerFindOne', 'id', id)
            const localVarPath = `/api/product/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate: async (id: string, updateProductDto: UpdateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productControllerUpdate', 'id', id)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('productControllerUpdate', 'updateProductDto', updateProductDto)
            const localVarPath = `/api/product/edit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerCreate(createProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [name] Product name
         * @param {ProductControllerFindAllStatusEnum} [status] Product status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFindAll(page?: number, perpage?: number, name?: string, status?: ProductControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizUserControllerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFindAll(page, perpage, name, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFindAllActive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerFindAllActive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFindAllActive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productControllerFindAllActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFindAttributes(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerFindAttributes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFindAttributes(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productControllerFindAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productControllerUpdate(id, updateProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerCreate200Response> {
            return localVarFp.productControllerCreate(createProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [name] Product name
         * @param {ProductControllerFindAllStatusEnum} [status] Product status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAll(page?: number, perpage?: number, name?: string, status?: ProductControllerFindAllStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<BizUserControllerList200Response> {
            return localVarFp.productControllerFindAll(page, perpage, name, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAllActive(options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerFindAllActive200Response> {
            return localVarFp.productControllerFindAllActive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindAttributes(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerFindAttributes200Response> {
            return localVarFp.productControllerFindAttributes(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerCreate200Response> {
            return localVarFp.productControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductControllerCreate200Response> {
            return localVarFp.productControllerUpdate(id, updateProductDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @param {CreateProductDto} createProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerCreate(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerCreate(createProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Default value is 1
     * @param {number} [perpage] Default value is 20
     * @param {string} [name] Product name
     * @param {ProductControllerFindAllStatusEnum} [status] Product status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerFindAll(page?: number, perpage?: number, name?: string, status?: ProductControllerFindAllStatusEnum, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerFindAll(page, perpage, name, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerFindAllActive(options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerFindAllActive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerFindAttributes(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerFindAttributes(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productControllerUpdate(id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productControllerUpdate(id, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProductControllerFindAllStatusEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type ProductControllerFindAllStatusEnum = typeof ProductControllerFindAllStatusEnum[keyof typeof ProductControllerFindAllStatusEnum];


/**
 * RetailApi - axios parameter creator
 * @export
 */
export const RetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateRetailDto} createRetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retailControllerCreate: async (createRetailDto: CreateRetailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRetailDto' is not null or undefined
            assertParamExists('retailControllerCreate', 'createRetailDto', createRetailDto)
            const localVarPath = `/api/stamp/retail/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRetailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {string} [stampCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retailControllerFindAll: async (page?: number, perpage?: number, fromDate?: string, toDate?: string, stampCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stamp/retail/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (stampCode !== undefined) {
                localVarQueryParameter['stampCode'] = stampCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retailControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retailControllerFindOne', 'id', id)
            const localVarPath = `/api/stamp/retail/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetailApi - functional programming interface
 * @export
 */
export const RetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateRetailDto} createRetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retailControllerCreate(createRetailDto: CreateRetailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetailControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retailControllerCreate(createRetailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RetailApi.retailControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {string} [stampCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retailControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: string, stampCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizUserControllerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retailControllerFindAll(page, perpage, fromDate, toDate, stampCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RetailApi.retailControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retailControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetailControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retailControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RetailApi.retailControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RetailApi - factory interface
 * @export
 */
export const RetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetailApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateRetailDto} createRetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retailControllerCreate(createRetailDto: CreateRetailDto, options?: RawAxiosRequestConfig): AxiosPromise<RetailControllerCreate200Response> {
            return localVarFp.retailControllerCreate(createRetailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {string} [stampCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retailControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: string, stampCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<BizUserControllerList200Response> {
            return localVarFp.retailControllerFindAll(page, perpage, fromDate, toDate, stampCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retailControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RetailControllerCreate200Response> {
            return localVarFp.retailControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetailApi - object-oriented interface
 * @export
 * @class RetailApi
 * @extends {BaseAPI}
 */
export class RetailApi extends BaseAPI {
    /**
     * 
     * @param {CreateRetailDto} createRetailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetailApi
     */
    public retailControllerCreate(createRetailDto: CreateRetailDto, options?: RawAxiosRequestConfig) {
        return RetailApiFp(this.configuration).retailControllerCreate(createRetailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Default value is 1
     * @param {number} [perpage] Default value is 20
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {string} [stampCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetailApi
     */
    public retailControllerFindAll(page?: number, perpage?: number, fromDate?: string, toDate?: string, stampCode?: string, options?: RawAxiosRequestConfig) {
        return RetailApiFp(this.configuration).retailControllerFindAll(page, perpage, fromDate, toDate, stampCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetailApi
     */
    public retailControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return RetailApiFp(this.configuration).retailControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StampApi - axios parameter creator
 * @export
 */
export const StampApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckStampDto} checkStampDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampControllerCheckStamp: async (checkStampDto: CheckStampDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkStampDto' is not null or undefined
            assertParamExists('stampControllerCheckStamp', 'checkStampDto', checkStampDto)
            const localVarPath = `/api/stamp/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkStampDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StampApi - functional programming interface
 * @export
 */
export const StampApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StampApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CheckStampDto} checkStampDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stampControllerCheckStamp(checkStampDto: CheckStampDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StampControllerCheckStamp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stampControllerCheckStamp(checkStampDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StampApi.stampControllerCheckStamp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StampApi - factory interface
 * @export
 */
export const StampApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StampApiFp(configuration)
    return {
        /**
         * 
         * @param {CheckStampDto} checkStampDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampControllerCheckStamp(checkStampDto: CheckStampDto, options?: RawAxiosRequestConfig): AxiosPromise<StampControllerCheckStamp200Response> {
            return localVarFp.stampControllerCheckStamp(checkStampDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StampApi - object-oriented interface
 * @export
 * @class StampApi
 * @extends {BaseAPI}
 */
export class StampApi extends BaseAPI {
    /**
     * 
     * @param {CheckStampDto} checkStampDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    public stampControllerCheckStamp(checkStampDto: CheckStampDto, options?: RawAxiosRequestConfig) {
        return StampApiFp(this.configuration).stampControllerCheckStamp(checkStampDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StampTemplateApi - axios parameter creator
 * @export
 */
export const StampTemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerActive: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stampTemplateControllerActive', 'id', id)
            const localVarPath = `/api/stamp-template/active/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateStampTemplateDto} createStampTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerCreate: async (createStampTemplateDto: CreateStampTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStampTemplateDto' is not null or undefined
            assertParamExists('stampTemplateControllerCreate', 'createStampTemplateDto', createStampTemplateDto)
            const localVarPath = `/api/stamp-template/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStampTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [name] 
         * @param {STAMPTEMPLATESTATUS} [status] active: 1, inactive: 2
         * @param {STAMPTEMPLATESIZE} [size] 15x15-6, 25x15-4, 35x22-3, 46x34-2, 15x15-4, 20x20-3, 30x30-2, 25x15-3, 35x22-2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerFindAll: async (page?: number, perpage?: number, name?: string, status?: STAMPTEMPLATESTATUS, size?: STAMPTEMPLATESIZE, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stamp-template/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerFindAllActive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stamp-template/list-active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stampTemplateControllerFindOne', 'id', id)
            const localVarPath = `/api/stamp-template/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerInactive: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stampTemplateControllerInactive', 'id', id)
            const localVarPath = `/api/stamp-template/inactive/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateStampTemplateDto} updateStampTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerUpdate: async (id: string, updateStampTemplateDto: UpdateStampTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stampTemplateControllerUpdate', 'id', id)
            // verify required parameter 'updateStampTemplateDto' is not null or undefined
            assertParamExists('stampTemplateControllerUpdate', 'updateStampTemplateDto', updateStampTemplateDto)
            const localVarPath = `/api/stamp-template/edit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStampTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StampTemplateApi - functional programming interface
 * @export
 */
export const StampTemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StampTemplateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stampTemplateControllerActive(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stampTemplateControllerActive(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StampTemplateApi.stampTemplateControllerActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateStampTemplateDto} createStampTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stampTemplateControllerCreate(createStampTemplateDto: CreateStampTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StampTemplateControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stampTemplateControllerCreate(createStampTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StampTemplateApi.stampTemplateControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [name] 
         * @param {STAMPTEMPLATESTATUS} [status] active: 1, inactive: 2
         * @param {STAMPTEMPLATESIZE} [size] 15x15-6, 25x15-4, 35x22-3, 46x34-2, 15x15-4, 20x20-3, 30x30-2, 25x15-3, 35x22-2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stampTemplateControllerFindAll(page?: number, perpage?: number, name?: string, status?: STAMPTEMPLATESTATUS, size?: STAMPTEMPLATESIZE, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BizUserControllerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stampTemplateControllerFindAll(page, perpage, name, status, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StampTemplateApi.stampTemplateControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stampTemplateControllerFindAllActive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StampTemplateControllerFindAllActive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stampTemplateControllerFindAllActive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StampTemplateApi.stampTemplateControllerFindAllActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stampTemplateControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StampTemplateControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stampTemplateControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StampTemplateApi.stampTemplateControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stampTemplateControllerInactive(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stampTemplateControllerInactive(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StampTemplateApi.stampTemplateControllerInactive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateStampTemplateDto} updateStampTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stampTemplateControllerUpdate(id: string, updateStampTemplateDto: UpdateStampTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StampTemplateControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stampTemplateControllerUpdate(id, updateStampTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StampTemplateApi.stampTemplateControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StampTemplateApi - factory interface
 * @export
 */
export const StampTemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StampTemplateApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerActive(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.stampTemplateControllerActive(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateStampTemplateDto} createStampTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerCreate(createStampTemplateDto: CreateStampTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<StampTemplateControllerCreate200Response> {
            return localVarFp.stampTemplateControllerCreate(createStampTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Default value is 1
         * @param {number} [perpage] Default value is 20
         * @param {string} [name] 
         * @param {STAMPTEMPLATESTATUS} [status] active: 1, inactive: 2
         * @param {STAMPTEMPLATESIZE} [size] 15x15-6, 25x15-4, 35x22-3, 46x34-2, 15x15-4, 20x20-3, 30x30-2, 25x15-3, 35x22-2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerFindAll(page?: number, perpage?: number, name?: string, status?: STAMPTEMPLATESTATUS, size?: STAMPTEMPLATESIZE, options?: RawAxiosRequestConfig): AxiosPromise<BizUserControllerList200Response> {
            return localVarFp.stampTemplateControllerFindAll(page, perpage, name, status, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerFindAllActive(options?: RawAxiosRequestConfig): AxiosPromise<StampTemplateControllerFindAllActive200Response> {
            return localVarFp.stampTemplateControllerFindAllActive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StampTemplateControllerCreate200Response> {
            return localVarFp.stampTemplateControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerInactive(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.stampTemplateControllerInactive(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateStampTemplateDto} updateStampTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampTemplateControllerUpdate(id: string, updateStampTemplateDto: UpdateStampTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<StampTemplateControllerCreate200Response> {
            return localVarFp.stampTemplateControllerUpdate(id, updateStampTemplateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StampTemplateApi - object-oriented interface
 * @export
 * @class StampTemplateApi
 * @extends {BaseAPI}
 */
export class StampTemplateApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampTemplateApi
     */
    public stampTemplateControllerActive(id: string, options?: RawAxiosRequestConfig) {
        return StampTemplateApiFp(this.configuration).stampTemplateControllerActive(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateStampTemplateDto} createStampTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampTemplateApi
     */
    public stampTemplateControllerCreate(createStampTemplateDto: CreateStampTemplateDto, options?: RawAxiosRequestConfig) {
        return StampTemplateApiFp(this.configuration).stampTemplateControllerCreate(createStampTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Default value is 1
     * @param {number} [perpage] Default value is 20
     * @param {string} [name] 
     * @param {STAMPTEMPLATESTATUS} [status] active: 1, inactive: 2
     * @param {STAMPTEMPLATESIZE} [size] 15x15-6, 25x15-4, 35x22-3, 46x34-2, 15x15-4, 20x20-3, 30x30-2, 25x15-3, 35x22-2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampTemplateApi
     */
    public stampTemplateControllerFindAll(page?: number, perpage?: number, name?: string, status?: STAMPTEMPLATESTATUS, size?: STAMPTEMPLATESIZE, options?: RawAxiosRequestConfig) {
        return StampTemplateApiFp(this.configuration).stampTemplateControllerFindAll(page, perpage, name, status, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampTemplateApi
     */
    public stampTemplateControllerFindAllActive(options?: RawAxiosRequestConfig) {
        return StampTemplateApiFp(this.configuration).stampTemplateControllerFindAllActive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampTemplateApi
     */
    public stampTemplateControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return StampTemplateApiFp(this.configuration).stampTemplateControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampTemplateApi
     */
    public stampTemplateControllerInactive(id: string, options?: RawAxiosRequestConfig) {
        return StampTemplateApiFp(this.configuration).stampTemplateControllerInactive(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateStampTemplateDto} updateStampTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampTemplateApi
     */
    public stampTemplateControllerUpdate(id: string, updateStampTemplateDto: UpdateStampTemplateDto, options?: RawAxiosRequestConfig) {
        return StampTemplateApiFp(this.configuration).stampTemplateControllerUpdate(id, updateStampTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TraceApi - axios parameter creator
 * @export
 */
export const TraceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        traceControllerTrace: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('traceControllerTrace', 'code', code)
            const localVarPath = `/api/trace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TraceApi - functional programming interface
 * @export
 */
export const TraceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TraceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async traceControllerTrace(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TraceControllerTrace200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.traceControllerTrace(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TraceApi.traceControllerTrace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TraceApi - factory interface
 * @export
 */
export const TraceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TraceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        traceControllerTrace(code: string, options?: RawAxiosRequestConfig): AxiosPromise<TraceControllerTrace200Response> {
            return localVarFp.traceControllerTrace(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TraceApi - object-oriented interface
 * @export
 * @class TraceApi
 * @extends {BaseAPI}
 */
export class TraceApi extends BaseAPI {
    /**
     * 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TraceApi
     */
    public traceControllerTrace(code: string, options?: RawAxiosRequestConfig) {
        return TraceApiFp(this.configuration).traceControllerTrace(code, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CloneFileDto} cloneFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerCloneBizResource: async (cloneFileDto: CloneFileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloneFileDto' is not null or undefined
            assertParamExists('uploadControllerCloneBizResource', 'cloneFileDto', cloneFileDto)
            const localVarPath = `/api/upload/clone-biz-resource`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneFileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<File>} files The files to upload, max 20Mb, allow jpg, jpeg, png.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadBizImages: async (files: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadControllerUploadBizImages', 'files', files)
            const localVarPath = `/api/upload/biz-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} file The file to upload, max 10kb, allow jpg, jpeg, png, svg.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadStampTemplateImage: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadControllerUploadStampTemplateImage', 'file', file)
            const localVarPath = `/api/upload/stamp-template-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CloneFileDto} cloneFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadControllerCloneBizResource(cloneFileDto: CloneFileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadControllerCloneBizResource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadControllerCloneBizResource(cloneFileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.uploadControllerCloneBizResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<File>} files The files to upload, max 20Mb, allow jpg, jpeg, png.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadControllerUploadBizImages(files: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadControllerUploadBizImages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadControllerUploadBizImages(files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.uploadControllerUploadBizImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} file The file to upload, max 10kb, allow jpg, jpeg, png, svg.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadControllerUploadStampTemplateImage(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadControllerUploadBizImages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadControllerUploadStampTemplateImage(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.uploadControllerUploadStampTemplateImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * 
         * @param {CloneFileDto} cloneFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerCloneBizResource(cloneFileDto: CloneFileDto, options?: RawAxiosRequestConfig): AxiosPromise<UploadControllerCloneBizResource200Response> {
            return localVarFp.uploadControllerCloneBizResource(cloneFileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<File>} files The files to upload, max 20Mb, allow jpg, jpeg, png.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadBizImages(files: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<UploadControllerUploadBizImages200Response> {
            return localVarFp.uploadControllerUploadBizImages(files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} file The file to upload, max 10kb, allow jpg, jpeg, png, svg.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadStampTemplateImage(file: File, options?: RawAxiosRequestConfig): AxiosPromise<UploadControllerUploadBizImages200Response> {
            return localVarFp.uploadControllerUploadStampTemplateImage(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * 
     * @param {CloneFileDto} cloneFileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerCloneBizResource(cloneFileDto: CloneFileDto, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).uploadControllerCloneBizResource(cloneFileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<File>} files The files to upload, max 20Mb, allow jpg, jpeg, png.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerUploadBizImages(files: Array<File>, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).uploadControllerUploadBizImages(files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} file The file to upload, max 10kb, allow jpg, jpeg, png, svg.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerUploadStampTemplateImage(file: File, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).uploadControllerUploadStampTemplateImage(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} fullName 
         * @param {string} phone 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {number} [gender] 
         * @param {string} [email] 
         * @param {string} [dateOfBirth] 
         * @param {string} [identificationNumber] 
         * @param {string} [identificationIssuedPlace] 
         * @param {string} [identificationIssuedDate] 
         * @param {File} [avatarUpload] Upload avatar, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreateProfile: async (fullName: string, phone: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, gender?: number, email?: string, dateOfBirth?: string, identificationNumber?: string, identificationIssuedPlace?: string, identificationIssuedDate?: string, avatarUpload?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fullName' is not null or undefined
            assertParamExists('userControllerCreateProfile', 'fullName', fullName)
            // verify required parameter 'phone' is not null or undefined
            assertParamExists('userControllerCreateProfile', 'phone', phone)
            // verify required parameter 'provinceCode' is not null or undefined
            assertParamExists('userControllerCreateProfile', 'provinceCode', provinceCode)
            // verify required parameter 'districtCode' is not null or undefined
            assertParamExists('userControllerCreateProfile', 'districtCode', districtCode)
            // verify required parameter 'wardCode' is not null or undefined
            assertParamExists('userControllerCreateProfile', 'wardCode', wardCode)
            // verify required parameter 'addressDetail' is not null or undefined
            assertParamExists('userControllerCreateProfile', 'addressDetail', addressDetail)
            const localVarPath = `/api/user/create-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (fullName !== undefined) { 
                localVarFormParams.append('fullName', fullName as any);
            }
    
            if (phone !== undefined) { 
                localVarFormParams.append('phone', phone as any);
            }
    
            if (gender !== undefined) { 
                localVarFormParams.append('gender', gender as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (dateOfBirth !== undefined) { 
                localVarFormParams.append('dateOfBirth', dateOfBirth as any);
            }
    
            if (provinceCode !== undefined) { 
                localVarFormParams.append('provinceCode', provinceCode as any);
            }
    
            if (districtCode !== undefined) { 
                localVarFormParams.append('districtCode', districtCode as any);
            }
    
            if (wardCode !== undefined) { 
                localVarFormParams.append('wardCode', wardCode as any);
            }
    
            if (addressDetail !== undefined) { 
                localVarFormParams.append('addressDetail', addressDetail as any);
            }
    
            if (identificationNumber !== undefined) { 
                localVarFormParams.append('identificationNumber', identificationNumber as any);
            }
    
            if (identificationIssuedPlace !== undefined) { 
                localVarFormParams.append('identificationIssuedPlace', identificationIssuedPlace as any);
            }
    
            if (identificationIssuedDate !== undefined) { 
                localVarFormParams.append('identificationIssuedDate', identificationIssuedDate as any);
            }
    
            if (avatarUpload !== undefined) { 
                localVarFormParams.append('avatarUpload', avatarUpload as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fullName 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {number} [gender] 
         * @param {string} [email] 
         * @param {string} [dateOfBirth] 
         * @param {string} [identificationNumber] 
         * @param {string} [identificationIssuedPlace] 
         * @param {string} [identificationIssuedDate] 
         * @param {File} [avatarUpload] Upload avatar, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateProfile: async (fullName: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, gender?: number, email?: string, dateOfBirth?: string, identificationNumber?: string, identificationIssuedPlace?: string, identificationIssuedDate?: string, avatarUpload?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fullName' is not null or undefined
            assertParamExists('userControllerUpdateProfile', 'fullName', fullName)
            // verify required parameter 'provinceCode' is not null or undefined
            assertParamExists('userControllerUpdateProfile', 'provinceCode', provinceCode)
            // verify required parameter 'districtCode' is not null or undefined
            assertParamExists('userControllerUpdateProfile', 'districtCode', districtCode)
            // verify required parameter 'wardCode' is not null or undefined
            assertParamExists('userControllerUpdateProfile', 'wardCode', wardCode)
            // verify required parameter 'addressDetail' is not null or undefined
            assertParamExists('userControllerUpdateProfile', 'addressDetail', addressDetail)
            const localVarPath = `/api/user/update-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (gender !== undefined) { 
                localVarFormParams.append('gender', gender as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (dateOfBirth !== undefined) { 
                localVarFormParams.append('dateOfBirth', dateOfBirth as any);
            }
    
            if (fullName !== undefined) { 
                localVarFormParams.append('fullName', fullName as any);
            }
    
            if (provinceCode !== undefined) { 
                localVarFormParams.append('provinceCode', provinceCode as any);
            }
    
            if (districtCode !== undefined) { 
                localVarFormParams.append('districtCode', districtCode as any);
            }
    
            if (wardCode !== undefined) { 
                localVarFormParams.append('wardCode', wardCode as any);
            }
    
            if (addressDetail !== undefined) { 
                localVarFormParams.append('addressDetail', addressDetail as any);
            }
    
            if (identificationNumber !== undefined) { 
                localVarFormParams.append('identificationNumber', identificationNumber as any);
            }
    
            if (identificationIssuedPlace !== undefined) { 
                localVarFormParams.append('identificationIssuedPlace', identificationIssuedPlace as any);
            }
    
            if (identificationIssuedDate !== undefined) { 
                localVarFormParams.append('identificationIssuedDate', identificationIssuedDate as any);
            }
    
            if (avatarUpload !== undefined) { 
                localVarFormParams.append('avatarUpload', avatarUpload as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} fullName 
         * @param {string} phone 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {number} [gender] 
         * @param {string} [email] 
         * @param {string} [dateOfBirth] 
         * @param {string} [identificationNumber] 
         * @param {string} [identificationIssuedPlace] 
         * @param {string} [identificationIssuedDate] 
         * @param {File} [avatarUpload] Upload avatar, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreateProfile(fullName: string, phone: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, gender?: number, email?: string, dateOfBirth?: string, identificationNumber?: string, identificationIssuedPlace?: string, identificationIssuedDate?: string, avatarUpload?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreateProfile(fullName, phone, provinceCode, districtCode, wardCode, addressDetail, gender, email, dateOfBirth, identificationNumber, identificationIssuedPlace, identificationIssuedDate, avatarUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerCreateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} fullName 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {number} [gender] 
         * @param {string} [email] 
         * @param {string} [dateOfBirth] 
         * @param {string} [identificationNumber] 
         * @param {string} [identificationIssuedPlace] 
         * @param {string} [identificationIssuedDate] 
         * @param {File} [avatarUpload] Upload avatar, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateProfile(fullName: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, gender?: number, email?: string, dateOfBirth?: string, identificationNumber?: string, identificationIssuedPlace?: string, identificationIssuedDate?: string, avatarUpload?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLeaveBusiness200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateProfile(fullName, provinceCode, districtCode, wardCode, addressDetail, gender, email, dateOfBirth, identificationNumber, identificationIssuedPlace, identificationIssuedDate, avatarUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerUpdateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {string} fullName 
         * @param {string} phone 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {number} [gender] 
         * @param {string} [email] 
         * @param {string} [dateOfBirth] 
         * @param {string} [identificationNumber] 
         * @param {string} [identificationIssuedPlace] 
         * @param {string} [identificationIssuedDate] 
         * @param {File} [avatarUpload] Upload avatar, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreateProfile(fullName: string, phone: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, gender?: number, email?: string, dateOfBirth?: string, identificationNumber?: string, identificationIssuedPlace?: string, identificationIssuedDate?: string, avatarUpload?: File, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.userControllerCreateProfile(fullName, phone, provinceCode, districtCode, wardCode, addressDetail, gender, email, dateOfBirth, identificationNumber, identificationIssuedPlace, identificationIssuedDate, avatarUpload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} fullName 
         * @param {string} provinceCode 
         * @param {string} districtCode 
         * @param {string} wardCode 
         * @param {string} addressDetail 
         * @param {number} [gender] 
         * @param {string} [email] 
         * @param {string} [dateOfBirth] 
         * @param {string} [identificationNumber] 
         * @param {string} [identificationIssuedPlace] 
         * @param {string} [identificationIssuedDate] 
         * @param {File} [avatarUpload] Upload avatar, allow file type: jpg, jpeg, png and and size &lt; 2MB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateProfile(fullName: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, gender?: number, email?: string, dateOfBirth?: string, identificationNumber?: string, identificationIssuedPlace?: string, identificationIssuedDate?: string, avatarUpload?: File, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLeaveBusiness200Response> {
            return localVarFp.userControllerUpdateProfile(fullName, provinceCode, districtCode, wardCode, addressDetail, gender, email, dateOfBirth, identificationNumber, identificationIssuedPlace, identificationIssuedDate, avatarUpload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {string} fullName 
     * @param {string} phone 
     * @param {string} provinceCode 
     * @param {string} districtCode 
     * @param {string} wardCode 
     * @param {string} addressDetail 
     * @param {number} [gender] 
     * @param {string} [email] 
     * @param {string} [dateOfBirth] 
     * @param {string} [identificationNumber] 
     * @param {string} [identificationIssuedPlace] 
     * @param {string} [identificationIssuedDate] 
     * @param {File} [avatarUpload] Upload avatar, allow file type: jpg, jpeg, png and and size &lt; 2MB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerCreateProfile(fullName: string, phone: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, gender?: number, email?: string, dateOfBirth?: string, identificationNumber?: string, identificationIssuedPlace?: string, identificationIssuedDate?: string, avatarUpload?: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerCreateProfile(fullName, phone, provinceCode, districtCode, wardCode, addressDetail, gender, email, dateOfBirth, identificationNumber, identificationIssuedPlace, identificationIssuedDate, avatarUpload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} fullName 
     * @param {string} provinceCode 
     * @param {string} districtCode 
     * @param {string} wardCode 
     * @param {string} addressDetail 
     * @param {number} [gender] 
     * @param {string} [email] 
     * @param {string} [dateOfBirth] 
     * @param {string} [identificationNumber] 
     * @param {string} [identificationIssuedPlace] 
     * @param {string} [identificationIssuedDate] 
     * @param {File} [avatarUpload] Upload avatar, allow file type: jpg, jpeg, png and and size &lt; 2MB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerUpdateProfile(fullName: string, provinceCode: string, districtCode: string, wardCode: string, addressDetail: string, gender?: number, email?: string, dateOfBirth?: string, identificationNumber?: string, identificationIssuedPlace?: string, identificationIssuedDate?: string, avatarUpload?: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerUpdateProfile(fullName, provinceCode, districtCode, wardCode, addressDetail, gender, email, dateOfBirth, identificationNumber, identificationIssuedPlace, identificationIssuedDate, avatarUpload, options).then((request) => request(this.axios, this.basePath));
    }
}



